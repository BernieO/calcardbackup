#!/usr/bin/env bash

# calcardbackup by BernieO - extracts ownCloud/Nextcloud calendars and addressbooks
# Source: https://github.com/BernieO/calcardbackup
# Copyright (C) 2018 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

set -euo pipefail

# calcardbackup version:
version="0.8.2-3_no-fd (29.11.2018), AGPL-3.0"

###
### BEGIN: FUNCTION DEFINITIONS
###

_output() {
  # prints output, but only if not in batch mode (option -b|--batch)

  # use || instead of && so that function returns true in any case - corrected in ver. 0.1.2:
  [[ "${mode:-}" == "batch" ]] || "$@"
}

get_absolute_path() {
  # returns the absolute path to a given filepath which may be absolute or relative to a directory.
  # this is only needed and used for paths given by user via config-file (because config-file could be in a different dir from working dir or script dir)
  # arguments: ${1}=directory; ${2}=path to file (relative to ${1} or absolute)
  local absolute_path

  if [[ "${2}" != /* ]]; then
    # change path of ${2} (file) relative to ${1} (dir) to absolute path and remove trailing slashes:
    absolute_path="$(readlink -f "${1}/${2}")" || error_exit "ERROR: ${1}/${2} can't be canonicalized. Check given path in config-file!" "I need to be able to read the full path!"
  else
    # if ${2} contains already absolute path, then only remove trailing slashes:
    absolute_path="$(readlink -f "${2}")" || error_exit "ERROR: ${2} can't be canonicalized. Check given path in config-file!" "I need to be able to read the full path!"
  fi
  echo "${absolute_path}"
}

check_readable_file() {
  # checks, if a given path is a regular and readable file.
  # arguments: ${1} is path to file, ${2} is short verbal explanation of the file for error message.

  # $1 needs to be a regular file AND readable (not OR like in versions < 0.4.2-2)
  [[ -f "${1}" && -r "${1}" ]] || error_exit "ERROR: Can't read ${2}" "${1} needs to be a regular file and I need to be able to read it."
}

set_required_paths() {
  # sets required paths for script to work

  # store current directory, because we have to change dir later and need to be able to come back to where we were:
  working_dir="$(pwd)"
  # get path to scripts dir:
  script_dir="$(readlink -f "${BASH_SOURCE[0]}")" || error_exit "ERROR: Can't convert scripts directory to absolute path." "I need to be able to read the full path of this scripts directory!"

  script_dir="$(dirname "${script_dir}")"
}

load_default_values() {
  # assigns default-values as configuration (which will be overwritten later with values from config-file or options passed from command line).

  nextcloud_url="https://www.my_nextcloud.net"
  trustful_certificate="yes"
  users_file=""
  date_extension="-%Y-%m-%d"
  keep_days_like_time_machine="0"
  delete_backups_older_than="0"
  compress="yes"
  compression_method="tar.gz"
  encrypt_backup="no"
  gpg_passphrase="1234"
  backup_addressbooks="yes"
  backup_calendars="yes"
  include_shares="no"
  snap="no"
  fetch_from_database="yes"
}

read_config_file() {
  # reads calcardbackups config file (if passed with option -c or in case script is run with no option at all or only option -b)
  local temp

  # absolute path to config file:
  temp="$(readlink -f "${config_file}")" || error_exit "ERROR: path to config file '${config_file}' can't be canonicalized." "I need to be able to read the full path. Check given path!"
  config_file="${temp}"
  config_file_dir="$(dirname "${config_file}")"
  _output echo "+  Using configuration file ${config_file}, ignoring all other command line options."
  load_default_values # if more options have been passed to command: ignore all options except for -b

  # check if config file is a file and readable:
  check_readable_file "${config_file}" "calcardbackups config file."
  # check config file for correct syntax (only variable declarations, comments and empty lines allowed)
  regex='^([[:space:]]*|[[:space:]]*[a-z_]+="[^"]*"[[:space:]]*)(#.*)?$'
  while read -r line; do
    [[ ! "${line}" =~ ${regex} ]] && error_exit "ERROR: invalid config file! Only variable-declarations, comments and empty lines allowed." "Invalid line: '${line}'" "Edit configuration file and run sript again."
  done <"${config_file}"
  # config file is readable and has correct syntax. So let's include it now (and overwrite default values):
  # shellcheck source=examples/calcardbackup.conf.example
  . "${config_file}"
  # make sure $nextcloud_path is set - otherwise print error and exit:
  [[ -z "${nextcloud_path:-}" ]] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud to be configured." "Check value of variable 'nextcloud_path' in ${config_file}"
  # change given paths (they might be relative to $config_file_dir) to absolute paths:
  # (this is only needed when using config-file, because config-file might be in different directory from working dir or scripts dir)
  nextcloud_path="$(get_absolute_path "${config_file_dir}" "${nextcloud_path}")"
  [[ -z "${users_file:-}" ]] || users_file="$(get_absolute_path "${config_file_dir}" "${users_file}")"
  [[ -z "${backupfolder:-}" ]] || backupfolder="$(get_absolute_path "${config_file_dir}" "${backupfolder}")"
}

preparations() {
  # checks for needed packages, reads config-file and validates user given values:

  # print timestamp
  _output printf '\n%s\n' "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  _output echo "+"
  _output echo "+  $(date) --> START calcardbackup ver. ${version}"
  _output echo "+  Checking dependencies and preparing..."

  # if option -c|--configfile or nothing at all or only -b is given - read config file (and overwrite default values):
  [[ -n "${config_file:-}" ]] && read_config_file
  # if neither configfile nor path to ownCloud/Nextcloud is given - error and exit:
  [[ -z "${config_file:-}" && -z "${nextcloud_path:-}" ]] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud as first argument!"

  # canonicalize and remove trailing slashes from $nextcloud_path:
  nextcloud_path="$(readlink -f "${nextcloud_path}")" || error_exit "ERROR: path to ownCloud/Nextcloud '${nextcloud_path}' can't be canonicalized." "I need to be able to read the full path. Check given path!"
  # remove trailing slashes from $nextcloud_url:
  while [[ "${nextcloud_url}" =~ /$ ]]; do
    nextcloud_url="${nextcloud_url%/}"
  done

  # location of ownClouds/Nextclouds config.php:
  # take account of env-variables ${NEXTCLOUD_CONFIG_DIR} and ${OWNCLOUD_CONFIG_DIR}
  # for ${NEXTCLOUD_CONFIG_DIR} see: https://github.com/nextcloud/server/issues/300
  # for ${OWNCLOUD_CONFIG_DIR} see:  https://github.com/owncloud/core/pull/27874
  if [[ -n "${NEXTCLOUD_CONFIG_DIR:-}" && -n "${OWNCLOUD_CONFIG_DIR:-}" ]]; then
    # if both environment variables are set: error and exit, because this script does not now which one to use:
    error_exit "ERROR: both environment variables are set: NEXTCLOUD_CONFIG_DIR and OWNCLOUD_CONFIG_DIR" "Unset one of the two and run script again."
  elif [[ -z "${NEXTCLOUD_CONFIG_DIR:-}" && -z "${OWNCLOUD_CONFIG_DIR:-}" ]]; then
    # if both environment variables are empty or unset - use the standard as path to config.php:
    configphp="${nextcloud_path}/config/config.php"
  else
    # if ${NEXTCLOUD_CONFIG_DIR} is not empty, use it as pathname to config directory:
    [[ -n "${NEXTCLOUD_CONFIG_DIR:-}" ]] && configphp="${NEXTCLOUD_CONFIG_DIR}"
    # if ${OWNCLOUD_CONFIG_DIR} is not empty, use it as pathname to config directory:
    [[ -n "${OWNCLOUD_CONFIG_DIR:-}" ]] && configphp="${OWNCLOUD_CONFIG_DIR}"
    # remove trailing slashes from pathname to config directory:
    while [[ "${configphp}" =~ /$ ]]; do
      configphp="${configphp%/}"
    done
    # add filename (config.php) to pathname:
    configphp="${configphp}/config.php"
  fi

  # check $include_shares for valid value (could only be invalid when using config-file):
  if [[ ! "${include_shares}" =~ ^(yes|no)$ ]]; then
    _output echo "-- WARNING: Parameter 'include_shares' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: include_shares=\"no\""
    include_shares="no"
  fi

  # check $fetch_from_database for valid value (could only be invalid when using config-file):
  if [[ ! "${fetch_from_database}" =~ ^(yes|no)$ ]]; then
    _output echo "-- WARNING: Parameter 'fetch_from_database' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: fetch_from_database=\"yes\""
    fetch_from_database="yes"
  fi

  # check for package curl
  command -v curl > /dev/null || curl_installed="no"
  if [[ ${curl_installed:-} == "no" ]]; then
    # cURL is not necessarily needed for fetching data from database, but cURL is indeed needed to get
    # calendars/addressbooks via http. So error and exit, if fetch_from_database="no":
    [[ ${fetch_from_database} == "yes" ]] && _output echo "+  Info: cURL not installed. Can't detect vendor."
    if [[ ${fetch_from_database} == "no" ]]; then
      [[ -z "${config_file:-}" ]] && error_exit "ERROR: Package 'curl' is needed for running this script with option -g." "Run script again without option '-g' or install cURL with 'apt-get install curl'."
      [[ -n "${config_file:-}" ]] && error_exit "ERROR: Package 'curl' is needed for running this script with 'fetch_from_database=\"no\"'." "Run script again with 'fetch_from_database=\"yes\"' or install cURL with 'apt-get install curl'."
    fi
  else
    curl_installed="yes"
    # this is only needed, if curl is installed:
    # check $trustful_certificate for valid value (could only be invalid when using config-file):
    if [[ ! "${trustful_certificate}" =~ ^(yes|no)$ ]]; then
      _output echo "-- NOTICE: Parameter 'trustful_certificate' is not valid (allowed is only \"yes\" or \"no\")."
      _output echo "-- NOTICE: Using default value instead: trustful_certificate=\"yes\""
      trustful_certificate="yes"
    fi
    # assign insecure option for curl (depending on value given by user):
    [[ "${trustful_certificate}" == "yes" ]] && trust=""
    [[ "${trustful_certificate}" == "no" ]] && trust="--insecure"
  fi
  # variable $trustful_certificate is not needed anymore:
  unset -v trustful_certificate

  # if $users_file is unset and we fetch everything from database - do a complete backup:
  if [[ -z ${users_file} ]]; then
    if [[ ${fetch_from_database} == "yes" ]]; then
      if [[ ${include_shares} == "yes" ]]; then
        ignore=", but ignore shared ones."
        include_shares="no"
      fi
      _output echo "+  no usersfile given: will backup all available items${ignore:-.}"
      unset -v ignore
      complete_backup_from_database="yes"
    elif [[ ${fetch_from_database} == "no" ]]; then
      [[ -z "${config_file:-}" ]] && error_exit "file with usernames and according passwords must be passed to this script when using option '-g'!"
      [[ -n "${config_file:-}" ]] && error_exit "file with usernames and according passwords not configured!" "Declare path in configuration file under 'users_file'"
    fi
  fi
  # if $users_file is set: check for file with usernames (+passwords)
  if [[ -n ${users_file} ]]; then
    if [[ "${fetch_from_database}" == "yes" ]]; then
      # either users.txt is found and readable OR do a complete backup from database:
      [[ -f "${users_file}" && -r "${users_file}" ]] || complete_backup_from_database="yes"
      if [[ "${complete_backup_from_database:-}" == "yes" ]]; then
        _output echo "+  file with usernames and passwords not found:"
        _output echo "+     - will fetch all available items from database"
        if [[ "${include_shares}" == "yes" ]]; then
          # don't include shared items when doing a complete backup - will backup everything anyway:
          _output echo "+     - ignoring option to include shared items"
          include_shares="no"
        fi
      fi
    elif [[ "${fetch_from_database}" == "no" ]]; then
      # check if users.txt is a file and readable and error and exit if not, because we need that file when not fetching things from database:
      check_readable_file "${users_file}" "file with usernames and passwords."
    fi
  fi

  # if $backupfolder is empty or not set: set it to 'backups/' in script's dir
  [[ -z "${backupfolder:-}" ]] && backupfolder="${script_dir}/backups/"
  # canonicalize path to backupfolder (writeable test will follow later):
  backupfolder="$(readlink -f "${backupfolder}")" || error_exit "ERROR: path to output directory '${backupfolder}' can't be canonicalized." "I need to be able to read the full path. Check given path!"
  # set path to temporary file (needed, because filedescriptor can't be used):
  tempfile="${backupfolder}/tempfile"

  # make sure the configured date format in $date_extension is valid:
  if [[ ! "$(date +"${date_extension}" 2>/dev/null)" ]]; then
    [[ -z "${config_file:-}" ]] && _output echo "-- NOTICE: Argument to option '-d|--date' has no valid format (check 'man date' for valid formats)."
    [[ -n "${config_file:-}" ]] && _output echo "-- NOTICE: Parameter 'date_extension' has no valid format (check 'man date' for valid formats)."
    _output echo "-- NOTICE: Using default value instead: \"-%Y-%m-%d\""
    date_extension="-%Y-%m-%d"
  fi

  # make sure $keep_days_like_time_machine is a positive integer and set it to the default (0) if not:
  if [[ ! "${keep_days_like_time_machine:-}" =~ ^[0-9]+$ ]]; then
    [[ -z "${config_file:-}" ]] && _output echo "-- NOTICE: Argument to option '-ltm/--like-time-machine' is not a positive number."
    [[ -n "${config_file:-}" ]] && _output echo "-- NOTICE: Parameter 'keep_days_like_time_machine' is not a positive number."
    _output echo "-- NOTICE: Using default value of 0 instead (keeping everything)."
    keep_days_like_time_machine="0"
  fi

  # make sure $delete_backups_older_than is a positive integer and set it to default (0) if not:
  if [[ ! "${delete_backups_older_than}" =~ ^[0-9]+$ ]]; then
    [[ -z "${config_file:-}" ]] && _output echo "-- NOTICE: Argument to option '-r/--remove' is not a positive number."
    [[ -n "${config_file:-}" ]] && _output echo "-- NOTICE: Parameter 'delete_backups_older_than' is not a positive number."
    _output echo "-- NOTICE: Using default value of 0 instead (not deleting anything)."
    delete_backups_older_than="0"
  fi

  # check value $compression_method:
  if [[ "${compression_method}" == "zip" ]]; then
    # check for package zip:
    command -v zip > /dev/null || error_exit "ERROR: You chose to compress backed up files with 'zip' instead of 'tar.gz'." "Therefore package 'zip' is needed. Install with 'apt-get install zip' and run script again"
  elif [[ "${compression_method}" != "tar.gz" ]]; then
    # if $compression_method is set to something else than "zip" or "tar.gz" - use "tar.gz":
    _output echo "-- NOTICE: Parameter 'compression_method' is set to unsupported format. Using default value 'tar.gz'."
    compression_method="tar.gz"
  fi

  # check $encrypt_backup for valid value (could only be invalid when using config-file):
  if [[ ! "${encrypt_backup}" =~ ^(yes|no)$ ]]; then
    _output echo "-- WARNING: Parameter 'encrypt_backup' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: encrypt_backup=\"no\""
    encrypt_backup="no"
  elif [[ "${encrypt_backup}" == "yes" ]]; then
    # check for package gpg:
    command -v gpg > /dev/null || error_exit "ERROR: You chose to encrypt your backup." "Therefore package 'gnupg' is needed. Install with 'apt-get install gnupg' and run script again"
    if [[ "${compress}" == "no" ]]; then
      _output echo "-- WARNING: Can't encrypt uncompressed backup."
      _output echo "-- WARNING: Changing from uncompress to compress backup"
      compress="yes"
    fi
    if [[ -z "${config_file:-}" ]]; then
      # get passphrase from on commandline given file:
      check_readable_file "${passphrase_file}" "file with passphrase."
      # read first line from on commandline given file and use that as passphrase:
      read -r gpg_passphrase <"${passphrase_file}"
      # variable $passphrase_file is not needed anymore:
      unset -v passphrase_file
    fi
    # error and exit, if backup shall be encrypted, but passphrase is on example value (1234) or empty:
    if [[ "${gpg_passphrase}" =~ ^(1234|)$ ]]; then
      [[ -z "${config_file:-}" ]] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change passphrase in file with passphrase and run sript again."
      [[ -n "${config_file:-}" ]] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change 'gpg_passphrase' in configuration file and run sript again."
    fi
  fi

  # check $snap for valid value (could only be invalid when using config-file):
  if [[ ! "${snap}" =~ ^(yes|no)$ ]]; then
    _output echo "-- WARNING: Parameter 'snap' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: snap=\"no\""
    snap="no"
  fi

  # make sure nextcloud.mysql-client is available when configured to use nextcloud-snap:
  if [[ "${snap}" == "yes" ]]; then
    command -v nextcloud.mysql-client > /dev/null || error_exit "ERROR: nextcloud-snaps cli-utility 'nextcloud.mysql-client' not found!" "To work with nextcloud-snap this script needs to be invoked  with sudo (even when root)." "If the script has been invoked with sudo: are you sure you are using nextcloud-snap?"
  fi
}

getvalue_from_configphp() {
  # reads a line with a given paramter from config.php and echoes the parameters value
  # arguments: ${1} is parameter which value should be returned

  # Notice: multi-line comments (/* ... */) are not recognized, if no marker at beginning of line. The first occurence of ${1} will be returned.
  # This might be a problem: because wrong value might be returned, if value is also present in a multi-line comment before the actual declaration in config.php!
  regex="^[[:space:]]*'${1}'.*"
  while read -r line; do
    [[ "${line}" =~ $regex ]] && break
    line=""
  done <"${configphp}"

  # if parameter was found ($line is not empty) - manipulate $line to only return value and nothing else:
  if [[ "${line:-}" != "" ]]; then
    line=${line%\'*}    # throw away end including last '
    line=${line##*\'}   # throw away beginning including last '
  else
    line="value is unset"
  fi
  echo "${line}"
}

read_config_php() {
  # reads config.php and assigns different paramters we need to know

  # check whether Nextclouds config-file is readable:
  check_readable_file "${configphp}" "configuration file of your Own-/Nextcloud installation."

  # get dbtableprefix for prefix string of table names:
  dbtableprefix="$(getvalue_from_configphp "dbtableprefix")"
  # set default dbtableprefix if unset in config.php:
  [[ "${dbtableprefix:-}" == "value is unset" ]] && dbtableprefix="oc_"

  # get version of ownCloud/Nextcloud and configure correct dav-endpoint:
  version_config_php="$(getvalue_from_configphp "version")"
  mainversion=${version_config_php%%.*}   # $mainversion is only first number
  minimumversion="5"
  davchangeversion="9"
  # error and exit, if $mainversion < 5 (because ownCloud < 5.0 is not supported by calcardbackup):
  [[ "${mainversion}" -lt "${minimumversion}" ]] && error_exit "ERROR: This script only works with versions >= 5.0." "You are using ownCloud ${version_config_php}."
  if [[ "${mainversion}" -ge "${davchangeversion}" ]]; then
    # Values for ownCloud/Nextcloud >= 9.0:
    caldav="dav"
    carddav="dav"
    table_calendars="${dbtableprefix}calendars"
    table_addressbooks="${dbtableprefix}addressbooks"
    row_principaluri="principaluri"
    if [[ "${include_shares}" == "yes" ]]; then
      table_shares="${dbtableprefix}dav_shares"
      row_share_principaluri="principaluri"
      row_share_type="type"
      row_share_resourceid="resourceid"
    fi
    if [[ "${fetch_from_database}" == "yes" ]]; then
      table_cards="${dbtableprefix}cards"
      table_calendarobjects="${dbtableprefix}calendarobjects"
    fi
    # next line is needed for addressbook-export from ownCloud/Nextcloud >= 9.0:
    extra_users="users/"
  else
    # Values for ownCloud < 9.0:
    caldav="caldav"
    carddav="carddav"
    table_calendars="${dbtableprefix}clndr_calendars"
    table_addressbooks="${dbtableprefix}contacts_addressbooks"
    row_principaluri="userid"
    if [[ "${include_shares}" == "yes" ]]; then
      table_shares="${dbtableprefix}share"
      row_share_principaluri="share_with"
      row_share_type="item_type"
      row_share_type_group="share_type" # needed for ownCloud < 9.0 to identify, if shared with group (and not with user)
      row_share_resourceid="item_source"
    fi
    if [[ "${fetch_from_database}" == "yes" ]]; then
      # shellcheck disable=SC2034
      table_cards="${dbtableprefix}contacts_cards"
      # shellcheck disable=SC2034
      table_calendarobjects="${dbtableprefix}clndr_objects"
    fi
    # must be empty for ownCloud < 9.0:
    extra_users=""
  fi
  # those values are the same for ownCloud < 9.0 and ownCloud/Nextcloud >= 9.0
  row_id="id"
  row_uri="uri"
  row_displayname="displayname"
  row_calendarcolor="calendarcolor"
  table_group_user="${dbtableprefix}group_user"
  # for calendarsubscriptions:
  table_calendarsubscriptions="${dbtableprefix}calendarsubscriptions"
  row_source="source"

  # get ownClouds/Nextclouds URL from config.php (overwrite.cli.url), compare to user given url ($nextcloud_url) and notice/error, if something is not as expected:
  local nextcloud_url_default="https://www.my_nextcloud.net"
  nextcloud_url_overwrite="$(getvalue_from_configphp "overwrite.cli.url")"
  # remove trailing slashes from $nextcloud_url_overwrite:
  while [[ "${nextcloud_url_overwrite}" =~ /$ ]]; do
    nextcloud_url_overwrite="${nextcloud_url_overwrite%/}"
  done

  if [[ "${nextcloud_url}" != "${nextcloud_url_default}" && "${nextcloud_url}" != "${nextcloud_url_overwrite}" && "${nextcloud_url_overwrite}" != "value is unset" ]]; then
    # use given URL but print notice, if $nextcloud_url has been configured to something other than default or overwrite.cli.url:
    # (last conditional expression in if statement above: make sure overwrite.cli.url is present and not empty):
    _output echo "-- NOTICE: Configured URL differs from 'overwrite.cli.url' in config.php"
    _output echo "-- ${nextcloud_url_overwrite}/   ==>   detected in ${configphp}"
    _output echo "-- ${nextcloud_url}/   ==>   given with option -a/--address or found in config file."
  elif [[ "${nextcloud_url}" == "${nextcloud_url_default}" && "${nextcloud_url_overwrite}" == "" ]]; then
    if [[ ${fetch_from_database} == "no" ]]; then
      # we want do download addressbooks/calendars - therefore the URL to ownCloud/Nextcloud server is required.
      # Error, if $nextcloud_url is on default value and config.php contains no overwrite.cli.url (or is empty)
      [[ -z "${config_file:-}" ]] && error_exit "ERROR: Can't retrieve url from ${configphp}" "Either don't use option '-g' or use option '-a' to pass URL to the script."
      [[ -n "${config_file:-}" ]] && error_exit "ERROR: Can't retrieve url from ${configphp}" "Either use 'fetch_from_database=\"yes\"' or give URL to 'nextcloud_url' in config file."
    else
      # if we fetch everything from database, we do not need the url of the ownCloud/Nextcloud server,
      # so avoid requests for ownCloud/Nextclouds in this case unknown URL with curl_installed="no"
      _output echo "-- NOTICE: Can't retrieve url from ${configphp}."
      _output echo "-- NOTICE: Continuing anyway, because fetching everything from database."
      # For this scenario this variable name is a bit misleading, but the script needs to act as if curl wasn't installed:
      curl_installed="no"
    fi
  elif [[ "${nextcloud_url_overwrite}" != "" ]]; then
    # if overwrite.cli.url is found (and $nextcloud_url is on default value): use it as $nextcloud_url
    nextcloud_url="${nextcloud_url_overwrite}"
  fi
  # Print url which will be used (only if curl is installed and if it differs from default value):
  if  [[ ${curl_installed} == "yes" ]]; then
    [[ ${nextcloud_url} == "${nextcloud_url_default}" ]] || _output echo "+  Using URL: ${nextcloud_url}"
  fi
}

read_status_php() {
  # checks for installation of ownCloud/Nextcloud by requesting $nextcloud_url/status.php and
  #     checks, if version number of $nextcloud_url/status.php correlates with version number of config.php

  # declare local variables:
  local status_php version_status_php versionstring_status_php regex line

  # set productname to dummy value - might be changed later:
  productname="Server"

  # store output of status.php in variable OR store curls exit code if it returns an empty string (which is in case of an error):
  status_php="$(curl -s ${trust} "${nextcloud_url}/status.php")" || cerror=$?

  # Output of status.php of the different ownCloud/Nextcloud versions:
  # ownCloud 5.0.9   {"installed":"true","version":"5.0.38","versionstring":"5.0.19","edition":""}
  # ownCloud 6.0.9   {"installed":"true","version":"6.0.9.2","versionstring":"6.0.9","edition":""}
  # ownCloud 7.0.15  {"installed":"true","version":"7.0.15.2","versionstring":"7.0.15","edition":""}
  # ownCloud 8.0.16  {"installed":true,"maintenance":false,"version":"8.0.16.3","versionstring":"8.0.16","edition":""}
  # ownCloud 8.1.12  {"installed":true,"maintenance":false,"version":"8.1.12.2","versionstring":"8.1.12","edition":""}
  # ownCloud 8.2.10  {"installed":true,"maintenance":false,"version":"8.2.10.2","versionstring":"8.2.10","edition":""}
  # ownCloud 9.0.8   {"installed":true,"maintenance":false,"version":"9.0.8.2","versionstring":"9.0.8","edition":""}
  # ownCloud 9.1.4   {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"9.1.4","edition":""}
  # ownCloud 10.0.0  {"installed":"true","maintenance":"false","needsDbUpgrade":"false","version":"10.0.0.12","versionstring":"10.0.0","edition":"Community","productname":"ownCloud"}
  # options in config.php introduced with ownCloud 10.0.0/10.0.6 generate a different status.php output:
  #   hide.version   {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"","versionstring":"","edition":"","productname":""}
  #   show_server_hostname {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"10.0.6.1","versionstring":"10.0.6","edition":"Community","productname":"ownCloud","hostname":"Hostname"}
  # Nextcloud 9.0.57 {"installed":true,"maintenance":false,"version":"9.0.57.2","versionstring":"9.0.57","edition":""}
  # Nextcloud 10.0.4 {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"10.0.4","edition":""}
  # Nextcloud 11.0.2 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"11.0.2.7","versionstring":"11.0.2","edition":"","productname":"Nextcloud"}
  # Nextcloud 12.0.0 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"12.0.0.29","versionstring":"12.0.0","edition":"","productname":"Nextcloud"}
  # Nextcloud 13.0.0 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"13.0.0.14","versionstring":"13.0.0","edition":"","productname":"Nextcloud"}
  # Nextcloud 14.0.0 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"14.0.0.19","versionstring":"14.0.0","edition":"","productname":"Nextcloud"}

  # regex matching versions mentioned above (tested with regex101.com):
  # (due to options added in ownCloud 10.0: version(string) maybe hidden or hostname maybe present (see hide.version, show_server_hostname in config.php))
  regex='^\{"installed":"?(true|false)"?,("maintenance":"?(true|false)"?,("needsDbUpgrade":"?(true|false)"?,)?)?"version":"[^"]*","versionstring":"[^"]*","edition":"[^"]*"(,"productname":"[^"]*")?(,"hostname":"[^"]*")?\}$'

  # check status.php for valid installation of ownCloud/Nextcloud:
  case ${fetch_from_database} in

    yes )
      if [[ ! "${status_php}" =~ ${regex} || -n ${cerror:-} ]]; then
        # if we fetch everything from database, this script can run anyway, even if ownCloud/Nextcloud is not online,
        # no further requests for ownCloud/Nextclouds in this case unknown URL with curl_installed="no" and return from this function:
        [[ -n ${cerror:-} ]] && _output echo "+  can't read status.php (cURL code '${cerror}')."
        [[ -z ${cerror:-} ]] && _output echo "+  no valid status.php found at ${nextcloud_url}."
      fi
      versionstring_status_php=${version_config_php%.*}
    ;;

    no )
      # perform some additional checks, because we are going to get calendars/addressbooks via https(s) from the server:

      if [[ ! "${status_php}" =~ ${regex} || -n ${cerror:-} ]]; then
        # if error code is set and we don't fetch things from database, call function to examine
        # curls exit code and print according message to stderr:
        [[ -n ${cerror:-} ]] && curl_error
        if [[ -z ${cerror:-} ]]; then
          [[ -z "${config_file:-}" ]] && error_exit "ERROR: No ownCloud/Nextcloud Installation found at ${nextcloud_url} !" "Try to run script again without using option '-g|--get-via-http'"
          [[ -n "${config_file:-}" ]] && error_exit "ERROR: No ownCloud/Nextcloud Installation found at ${nextcloud_url} !" "Try to run script again using 'fetch_from_database=\"yes\"' in config file."
        fi
      fi

      # get version from status.php:
      version_status_php=${status_php#*version\":\"}
      version_status_php=${version_status_php%%\"*}
      # get versionstring from status_php (needed for proper versioning (ownloud 5.0 has in version also only 3 numbers)):
      versionstring_status_php=${status_php#*versionstring\":\"}
      versionstring_status_php=${versionstring_status_php%%\"*}

      # check for missing version in status.php due to option in config.php introduced with ownCloud 10.0 ('hide.version' => true,):
      [[ -z "${version_status_php:-}" || -z "${versionstring_status_php:-}" ]] && {
        # version number hidden (empty): print notice and use values from config.php:
        _output echo "-- NOTICE: version number hidden in status.php."
        version_status_php=${version_config_php}
        versionstring_status_php=${version_config_php%.*}
      }

      # check for "needsDbUpgrade":true in status.php and exit if ownCloud/Nextcloud needs a DbUpgrade:
      regex='"needsDbUpgrade":"?true"?'
      if [[ "${status_php}" =~ ${regex} ]]; then
        [[ -z "${config_file:-}" ]] && error_exit "ERROR: ${nextcloud_url}/status.php reports \"needsDbUpgrade\":true" "You need to upgrade your ${productname} Installation before running this script again!" "Or run script again without option '-g|--get-via-http'"
        [[ -n "${config_file:-}" ]] && error_exit "ERROR: ${nextcloud_url}/status.php reports \"needsDbUpgrade\":true" "You need to upgrade your ${productname} Installation before running this script again!" "Or run script again with the default value 'fetch-from-database=\"yes\"' in config file '${config_file}'."
      fi

      # check whether version of config.php is the same than version of status.php:
      if [[ "${version_status_php}" != "${version_config_php}" ]]; then
         [[ -z "${config_file:-}" ]] && error_exit "ERROR: different versions detected:" "Version ${versionstring_status_php} found at ${nextcloud_url}" "Version ${version_config_php} found at ${nextcloud_path}" "check given path and given url (option -a)"
         [[ -n "${config_file:-}" ]] && error_exit "ERROR: different versions detected:" "Version ${versionstring_status_php} found at ${nextcloud_url}" "Version ${version_config_php} found at ${nextcloud_path}" "check configured path and url in config file '${config_file}'"
      fi

      # check for installed=true in status.php and exit if ownCloud/Nextcloud report installed:false:
      regex='"installed":"?true"?'
      [[ "${status_php}" =~ ${regex} ]] || error_exit "ERROR: ${nextcloud_url}/status.php does not contain \"installed\":\"true\"!" "You need to check your ${productname} Installation!"

      # check for maintenance=false for versions >= 8.0 in status.php and exit if ownCloud/Nextcloud in maintenance mode:
      if [[ "$mainversion" -ge 8 ]]; then
        regex='"maintenance":"?true"?'
        if [[ "${status_php}" =~ ${regex} ]]; then
          [[ -z "${config_file:-}" ]] && error_exit "ERROR: ${productname} is in maintenance mode!" "Disable maintenance mode with command \"sudo -u www-data php ${nextcloud_path}/occ maintenance:mode --off\" and run script again" "Another possibility is to not use option '-g|--get-via-http'."
          [[ -n "${config_file:-}" ]] && error_exit "ERROR: ${productname} is in maintenance mode!" "Disable maintenance mode with command \"sudo -u www-data php ${nextcloud_path}/occ maintenance:mode --off\" and run script again" "More recommended is to set the default 'fetch_from_database=\"yes\"' in the configuration file."
        fi
      fi
    ;;

  esac

  # detect whether Installation is Nextcloud or ownCloud (look in user documentation for productname) - no need to check for error, because empty file = can't detect vendor:
  curl -s ${trust} "${nextcloud_url}/core/doc/user/index.html" > "${tempfile}" || :
  regex="(Nextcloud|ownCloud)"
  line=""
  while read -r line; do
    [[ "${line}" =~ $regex ]] && break
    line=""
  done < "${tempfile}"
  if [[ "${line}" =~ Nextcloud ]]; then
    productname="Nextcloud"
  elif [[ "${line}" =~ ownCloud ]]; then
    productname="ownCloud"
  else {
    _output echo "-- Notice: can't detect vendor."
  }
  fi

  _output echo "+  ${productname} ${versionstring_status_php} detected."

}

get_database_details() {
  # reads database configuration from config.php and assigns variable $dbcommand which is used to issue database queries later on

  # read type of database being used (SQLite or MySQL/MariaDB)
  dbtype="$(getvalue_from_configphp "dbtype")"
  [[ "${dbtype}" == "value is unset" ]] && dbtype="sqlite3" # use default if unset in config.php
  case "${dbtype}" in
    mysql|pgsql)
      dbname="$(getvalue_from_configphp "dbname")"
      dbhost="$(getvalue_from_configphp "dbhost")"
      # use localhost as dbhost if unset in config.php
      # though (as per documentation) there is no default for dbhost, chances are quite high, that the database listens there:
      [[ "${dbhost}" == "value is unset" ]] && dbhost="localhost"
      # check whether dbhost contains socket or portnumber and store it for mysql/psql commands:
      if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
        # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
        [[ "${dbtype}" == "mysql" ]] && {
          dbprotocol="socket = ${dbhost#*:}"
          dbhost="${dbhost%%:*}"
        }
        [[ "${dbtype}" == "pgsql" ]] && {
          # for postgresql use socket as hostname:
          dbprotocol=""
          dbhost="--host=${dbhost#*:}"
        }
     elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
        # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
        [[ "${dbtype}" == "mysql" ]] && {
          dbprotocol="port = ${dbhost#*:}"
          dbhost="${dbhost%%:*}"
        }
        [[ "${dbtype}" == "pgsql" ]] && {
          # for postgresql use socket as hostname:
          dbprotocol="--port=${dbhost#*:}"
          dbhost="--host=${dbhost%%:*}"
        }
      else
        # dbhost contains only hostname - use empty value to tell mysql/psql to use default value:
        dbprotocol=""
        # make sure to also pass --host assignment to psql, if dbhost contains neither socket nor port:
        [[ "${dbtype}" == "pgsql" ]] && dbhost="--host=${dbhost}"
      fi
      dbuser="$(getvalue_from_configphp "dbuser")"
      dbpassword="$(getvalue_from_configphp "dbpassword")"
      [[ "${dbtype}" == "mysql" ]] && {
        # mysql>=5.6 throws a warning when using password on command line interface: https://bugs.mysql.com/bug.php?id=66546
        # avoiding that with option --defaults-extra-file and printf as suggested by Dave James Miller: https://stackoverflow.com/questions/20751352/suppress-warning-messages-using-mysql-from-within-terminal-but-password-written/20854048#comment42372603_22933056
        # ATTENTION: variable $dbcommand will be passed to command "eval" later. So better take care when adding new stuff to $dbcommand!
        case "${snap}" in
          no )
            # shellcheck disable=SC2016
            dbcommand='mysql -u "${dbuser}" -p"${dbpassword}" -h ${dbhost} ${dbprotocol} "${dbname}" -sre '
          ;;
          yes )
            # shellcheck disable=SC2016
            dbcommand='nextcloud.mysql-client --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = \"%s\"\nhost = %s\n%s" "${dbuser}" "${dbpassword}" "${dbhost}" "${dbprotocol}") "${dbname}" -sre '
          ;;
        esac
        # store type of database for output of script:
        database="MySQL/MariaDB"
      }
      [[ "${dbtype}" == "pgsql" ]] && {
        # set database command for PostgreSQL:
        # ATTENTION: variable $dbcommand will be passed to command "eval" later. So better take care when adding new stuff to $dbcommand!
        # no need to quote $dbhost and $dbprotocol here, because they can't contain spaces. Saves some lines of code (v0.7.2-22):
        # is $dbhost contains a socket, this will not be treated as a network connection by psql and this error may occur:
        # 'psql: FATAL: Peer authentication failed for user "USERNAME"'
        # see https://stackoverflow.com/a/26183931 and https://stackoverflow.com/a/21889759 to solve this error message.
        # shellcheck disable=SC2016,SC2086
        dbcommand='PGPASSWORD="${dbpassword}" psql ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -Aqtc '
        # store type of database for output of script:
        database="PostgreSQL"
     }
    ;;
    sqlite3)
      # check if command-line-interface of sqlite3 is installed:
      command -v sqlite3 > /dev/null || error_exit "ERROR: ${productname} database is sqlite3. Therefore this script requires package 'sqlite3'." "Install with 'apt-get install sqlite3' and run script again"
      datadirectory="$(getvalue_from_configphp "datadirectory")" # has to be absolute path for working Own-/Nextcloud, so no need to get absolute path
      [[ "${datadirectory}" == "value is unset" ]] && datadirectory="${nextcloud_path}/data" # use default if unset in config.php
      sqlite3_database="${datadirectory}/owncloud.db"
      # use options '-list' and '-separator "|"' for sqlite3 command, to override eventually existing user-specific config-file '~/.sqlite3rc':
      # ATTENTION: variable $dbcommand will be passed to command "eval" later. So better take care when adding new stuff to $dbcommand!
      dbcommand='sqlite3 -list -separator "|" owncloud.db ' # for database queries we do "cd ${datadirectory}" later so no need to use absolute path
      # store type of database for output of script:
      database="SQLite3"
      # check if sqlite3 database file is readable:
      check_readable_file "${sqlite3_database}" "${productname}s SQLite3 database."
    ;;
    *)
      # print error and exit, if used dbtype is not supported by calcardbackup:
      error_exit "ERROR: Unsupported Database type: ${dbtype}" "Only MySQL/MariaDB, SQLite3 and PostgreSQL are supported."
    ;;
  esac
  _output echo "+  Database of chosen ${productname} installation is ${database}."
}

read_users_txt() {
  # reads file with user credentials

  # split each line at the first colon (username:password) and store usernames and according passwords in array:
  readarray -t users < "${users_file}"
  for i in "${!users[@]}"; do
    user[$i]="${users[$i]%%:*}"
    pass[$i]="${users[$i]#*:}"
  done
}

create_backup_folder() {
  # creates backup folder and subfolder with date extension to store files

  # create backup folder:
  mkdir -p "${backupfolder}" || error_exit "ERROR: Backupfolder could not be created."

  # check if backupfolder is writable (could happen, if backupfolder was already existing created from another user):
  [[ -w "${backupfolder}" ]] || error_exit "ERROR: Backupfolder is not writable."

  day="$(date +"${date_extension}")"
  backupfolder_day="${backupfolder}/calcardbackup${day}"
  # store path to backup (depending on config, this value might get changed later to path to compressed- or encrypted-backup):
  path_to_backup="${backupfolder_day}"
  mkdir -p "${backupfolder_day}"
}

query_database() {
  # gets details of calendars/addressbooks from database
  # see next lines for description of arguments ${1} and ${2}

  table="${1}"  # ${table_calendars}, ${table_calendarsubscriptions} or ${table_addressbooks}
  item="${2}"   # "calendar", "calendarsubscription" or "addressbook", just a verbal description, needed for output messages

  _output echo "+  Looking for ${item}s in your ${productname}:"

  # change of directory needed for SQLite3, because ${datadirectory} could contain spaces and
  # sqlite3 would then need "${dboptions}" to avoid bashs word splitting, but mysql needs ${dboptions} word-splitted:
  [[ "${dbtype}" == "sqlite3" ]] && cd "${datadirectory}"

  # check if table exists:
  [[ "${dbtype}" == "mysql" && "${snap}" == "no" ]] && check_table="$(mysql -u "${dbuser}" -p"${dbpassword}" -h ${dbhost} ${dbprotocol} "${dbname}" -e "show tables like '${table}'")"
  [[ "${dbtype}" == "mysql" && "${snap}" == "yes" ]] && check_table="$(nextcloud.mysql-client --defaults-extra-file=<(printf '[client]\nuser = %s\npassword = \"%s\"\nhost = %s\n%s' "${dbuser}" "${dbpassword}" "${dbhost}" "${dbprotocol}") "${dbname}" -e "show tables like '${table}'")"
  [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table}'")"
  # shellcheck disable=SC2086
  [[ "${dbtype}" == "pgsql" ]] && check_table="$(PGPASSWORD="${dbpassword}" psql ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -qtc "SELECT * FROM ${table} LIMIT 1;")"

  if [[ "${check_table:-}" == "" ]]; then
    if [[ "${item}" != "calendarsubscription" ]]; then
      # print notice, if table doesn't exist (unnecessary for calendarsubscriptions):
      _output echo "-- NOTICE: table '${table}' containing ${item}s does not exist in database."
      _output echo "-- NOTICE: Looks like your ${productname} did not create any ${item}s yet."
    fi

  else
    # table exists

    # prepare database query:
    # fields to be read from database table:
    fields="${row_principaluri}, ${row_displayname}, ${row_uri}"
    # If we want to get addressbooks from the database (instead of downloading from ownCloud/Nextcloud) or
    # to be able to include shares we also need to get id of item (needs to be compared to $share_resourceid from $table_shares):
    [[ "${include_shares}" == "yes" || "${fetch_from_database}" == "yes" ]] && fields="${row_id}, ${fields}"
    [[ "${item}" == "calendar" && "${fetch_from_database}" == "yes" ]] && fields="coalesce(${row_calendarcolor},'NULL'), ${fields}"
    [[ "${item}" == "calendarsubscription" ]] && fields="${row_id}, ${row_principaluri}, ${row_displayname}, ${row_source}"
    # adjust output format of MySQL/MariaDB/PostgreSQL to match output of SQLite3 (field|field|field):
    [[ "${dbtype}" != "sqlite3" ]] && fields="CONCAT_WS('|', ${fields})"
    # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
    # shellcheck disable=SC2016
    db_query='"select ${fields} from ${table} order by id"'

    # read required fields from table and assign values to arrays:
    eval "${dbcommand}" "${db_query}" > "${tempfile}"
    while read -r line; do
      # make sure empty lines are not processed (PostgreSQL prints as last line in the results an empty line - don't know how to suppress that):
      [[ "${line:-}" == "" ]] && continue
      if [[ "${item}" == "calendar" && "${fetch_from_database}" == "yes" ]]; then
        calendarcolor+=("${line%%|*}") # store calendarcolor (first field) in array
        line="${line#*|}"          # cut first field (calendarcolor)
      fi
      if [[ "${include_shares}" == "yes" || "${fetch_from_database}" == "yes" || "${item}" == "calendarsubscription" ]]; then
        id+=("${line%%|*}")        # store id (first field) in array
        line="${line#*|}"          # cut first field (id)
      fi
      line="${line/principals\/users\/}" # remove "principals/users/" from line, to get username
      principal+=("${line%%|*}")   # store principal (=username, is first field) in array
      line="${line#*|}"            # cut first field (principal)
      displayname+=("${line%%|*}") # store displayname (is now first field) in array
      if [[ "${item}" == "calendarsubscription" ]]; then
        source+=("${line##*|}")    # store source (URL to calendarsubscription, last field) in array
      else
        uri+=("${line##*|}")       # store uri (last field) in array
      fi
    done < "${tempfile}"
  fi

  # switch back to original directory when using sqlite3 (use OR instead of AND to return true in any case - changed in 0.4.2-8):
  [[ "${dbtype}" != "sqlite3" ]] || cd "${working_dir}"
}

include_shares() {
  # looks for shared items and adds them to arrays created in function query_database()

  # database only needs to be queried once for table with infos about shares ($table_shares)
  # (because same table for shared calendars and shared addressbooks):
  if [[ "${read_shared:-}" == "" ]]; then
    read_shared=1

    # change of directory needed for SQLite3, because ${datadirectory} could contain spaces and
    # sqlite3 would then need "${dboptions}" to avoid bashs word splitting, but mysql needs ${dboptions} word-splitted:
    [[ "${dbtype}" == "sqlite3" ]] && cd "${datadirectory}"

    # check if table $table_shares exists:
    [[ "${dbtype}" == "mysql" && "${snap}" == "no" ]] && check_table="$(mysql -u "${dbuser}" -p"${dbpassword}" -h ${dbhost} ${dbprotocol} "${dbname}" -e "show tables like '${table_shares}'")"
    [[ "${dbtype}" == "mysql" && "${snap}" == "yes" ]] && check_table="$(nextcloud.mysql-client --defaults-extra-file=<(printf '[client]\nuser = %s\npassword = \"%s\"\nhost = %s\n%s' "${dbuser}" "${dbpassword}" "${dbhost}" "${dbprotocol}") "${dbname}" -e "show tables like '${table_shares}'")"
    [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table_shares}'")"
    # shellcheck disable=SC2086
    [[ "${dbtype}" == "pgsql" ]] && check_table="$(PGPASSWORD="${dbpassword}" psql ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -qtc "SELECT * FROM ${table_shares} LIMIT 1;")"

    if [[ "${check_table:-}" == "" ]]; then
      # print notice, if $table_shares doesn't exist:
      _output echo "-- NOTICE: table '${table_shares}' containing shared calendars/addressbooks does not exist in database."
      _output echo "-- NOTICE: Looks like there are no shared calenders/addressbooks in your ${productname}."

    else
      # table with info about shares ($table_shares) exists - read required fields from table and assign values to share_arrays

      # prepare database query
      # fields to be read from database table with shares:
      fields="${row_share_principaluri}, ${row_share_type}, ${row_share_resourceid}"
      # we also need to get share type to identify group-shares for ownCloud < 9.0:
      [[ "${mainversion}" -lt "${davchangeversion}" ]] && fields="${row_share_type_group}, ${fields}"
      # adjust output format of MySQL/MariaDB/PostgreSQL to match output of SQLite3 (field|field|field):
      [[ "${dbtype}" != "sqlite3" ]] && fields="CONCAT_WS('|', ${fields})"
      # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
      # shellcheck disable=SC2016
      db_query='"select ${fields} from ${table_shares} order by id"'

      # read required fields from table and assign values to share-arrays:
      eval "${dbcommand}" "${db_query}" > "${tempfile}"
      while read -r line; do
        # don't process empty lines (PostgreSQL returns am empty line after the result):
        [[ "${line:-}" == "" ]] && continue
        if [[ "${mainversion}" -lt "${davchangeversion}" ]]; then
          # for ownCloud < 9.0: store share_type_group (first field) in array
          # (share_type_group will be 0 for user-share, 1 for group-share, 3 for public-share):
          share_type_group+=("${line%%|*}") # first field contains share-type_group
          line="${line#*|}"                 # cut first field (share_type_group) from array
        fi
        line="${line/principals\/users\/}"  # remove "principals/users/" to get username ("/principals/groups" stays there for groupcheck later)
        share_principal+=("${line%%|*}")    # store share_principal (is now first field) in array
        line="${line#*|}"                   # cut first field (share-principal)
        share_type+=("${line%%|*}")         # store share_type (is now first field) in array
        share_resourceid+=("${line##*|}")   # store share_resourceid (last field) in array
      done < "${tempfile}"

      # we also need to get info about group members to be able to backup calendars/addressbooks which are shared to groups:
      # check if table group_user ($table_group_user) exists:
      [[ "${dbtype}" == "mysql" && "${snap}" == "no" ]] && check_table="$(mysql -u "${dbuser}" -p"${dbpassword}" -h ${dbhost} ${dbprotocol} "${dbname}" -e "show tables like '${table_group_user}'")"
      [[ "${dbtype}" == "mysql" && "${snap}" == "yes" ]] && check_table="$(nextcloud.mysql-client --defaults-extra-file=<(printf '[client]\nuser = %s\npassword = \"%s\"\nhost = %s\n%s' "${dbuser}" "${dbpassword}" "${dbhost}" "${dbprotocol}") "${dbname}" -e "show tables like '${table_group_user}'")"
      [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table_group_user}'")"
      # shellcheck disable=SC2086
      [[ "${dbtype}" == "pgsql" ]] && check_table="$(PGPASSWORD="${dbpassword}" psql ${dbhost} ${dbprotocol} -U "${dbuser}" -d "${dbname}" -qtc "SELECT * FROM ${table_group_user} LIMIT 1;")"

      if [[ "${check_table:-}" != "" ]]; then
        # table group_user exists -> read values in array grouplist:
        # fields to be read from table group_user:
        fields="gid, uid"
        # adjust output format of MySQL/MariaDB/PostgreSQL to match output of SQLite3 (field|field|field):
        [[ "${dbtype}" != "sqlite3" ]] && fields="CONCAT_WS('|', ${fields})"
        # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
        # shellcheck disable=SC2016
        db_query='"select ${fields} from ${table_group_user} order by gid"'

        # read values from database and create array with list of groups and their users:
        eval "${dbcommand}" "${db_query}" > "${tempfile}"
        while read -r line; do
          # don't process empty lines (PostgreSQL returns am empty line after the result):
          [[ "${line:-}" == "" ]] && continue
          grouplist+=("${line}")
        done < "${tempfile}"
      # no need for else section with error-message, because: if there is no group list - there are no groups, which is not a problem
      fi

    fi
    # switch back to original directory when using sqlite3 (use OR instead of AND to return true in any case - changed in 0.4.2-8):
    [[ "${dbtype}" != "sqlite3" ]] || cd "${working_dir}"
  fi

  # print notice, if no results were found (table $table_shares is empty) and return from this function (includ_shares):
  if [[ -z ${share_principal:-} ]]; then
    _output echo "-- NOTICE: Table '${table_shares}' is empty. There are no shared ${item}s in your ${productname}."
    return
  fi

  # declare local arrays and variables:
  local -a temp_principal temp_displayname temp_uri temp_id temp_calendarcolor
  local -i i s g

  # look for matches of share_resourceid of $table_shares and calendar/addressbook-ids and store values in a temporary array:
  # notice: share_resourceid doesn't get compared with id from same table ($table_shares), but
  #         with id from table containing calendars/addressbooks ($table_calendars/$table_addressbooks)
  for (( i=0; i<${#id[@]}; i++ )); do                    # go through calender/addressbook-ids
    for (( s=0; s<${#share_resourceid[@]}; s++ )); do    # go through share_resourceid
      # if share_resourceid matches calendar/addressbook-id, we need to add it to the temporary 'shares to be backed up'-arrays:
      if [[ "${share_resourceid[$s]}" == "${id[$i]}" && "${share_type[$s]}" == "${item}" ]]; then
        # make sure, principal of share is not a group (group will be treated below)
        # first expression in next line is for ownCloud/Nextcloud >= 9.0, the second one (after &&) is for ownCloud < 9.0:
        if [[ ! "${share_principal[$s]}" =~ principals/groups/ && ! "${share_type_group[$s]:-}" =~ ^1$ ]]; then
          # add identified dav-share (shared with a user!) to the temporary 'shares to be backed up'-arrays:
          temp_principal+=("${share_principal[$s]}")
          temp_uri+=("${uri[$i]}_shared_by_${principal[$i]}")
          temp_displayname+=("${displayname[$i]}_shared_by_${principal[$i]}")
          temp_id+=("${share_resourceid[$s]}")
          # in case it is a calendar - also add calendarcolor of original item to temp array with shared items:
          [[ "${item}" == "calendar" && "${fetch_from_database}" == "yes" ]] && temp_calendarcolor+=("${calendarcolor[$i]}")
        else
          # if share-principal is a group:
          #     go through list with groups and their users and
          #     add item to the temporary 'shares to be backed up'-arrays for all users of that very group:
          for g in "${!grouplist[@]}"; do
            if [[ "${share_principal[$s]#*principals/groups/}" == "${grouplist[$g]%|*}" ]]; then
              # if item owner is member of group:
              #     do not add item to 'shares to be backed up'-arrays for owner, instead continue with next element
              #     (owner is excluded here, because owners item will be downloaded anyway: it is already in the array with items to be downloaded):
              [[ "${grouplist[$g]#*|}" == "${principal[$i]}" ]] && continue
              # add details of item shared with group to temporary 'shares to be backed up'-arrays:
              temp_principal+=("${grouplist[$g]#*|}")
              temp_uri+=("${uri[$i]}_shared_by_${principal[$i]}")
              temp_displayname+=("${displayname[$i]}_shared_by_${principal[$i]}")
              temp_id+=("${share_resourceid[$s]}")
              # in case it is a calendar - also add calendarcolor of original item to temp array with shared items:
              [[ "${item}" == "calendar" && "${fetch_from_database}" == "yes" ]] && temp_calendarcolor+=("${calendarcolor[$i]}")
            fi
          done
        fi
      fi
    done
  done

  # make sure, that temporary arrays are only read if not empty. This can be the case, if there
  # are shared calendars, but no shared addressbooks (or vice versa) (v0.6.1):
  if [[ -n ${temp_principal:-} ]]; then
    # add values of temporary 'shares to be backed up'-arrays to arrays which will later be used to download the files:
    for (( i=0; i<${#temp_principal[@]}; i++ )); do
      principal+=("${temp_principal[$i]}")
      uri+=("${temp_uri[$i]}")
      displayname+=("${temp_displayname[$i]}")
      id+=("${temp_id[$i]}")
      [[ "${item}" == "calendar" && "${fetch_from_database}" == "yes" ]] && calendarcolor+=("${temp_calendarcolor[$i]}")
    done
  fi

  # unset arrays with infos about shares (from $table_shares), only after second run of this function:
  [[ ${read_shared} -eq 2 ]] && unset -v share_type_group share_principal share_type share_resourceid grouplist

  # set $read_shared to 2 for eventually second run of this function
  read_shared=2

}

get_icsvcf_files() {
  # looks for matches between array with user and arrays (created by database-queries) and then downloads addressbooks/calendars
  # see next lines for description of arguments:

  local item="${1}"            # items to be downloaded: "addressbook" or "calendar"
  local item_extension="${2}"  # filename extension: ".vcf" or ".ics"
  local item_header="${3}"     # valid vcf/ics-header (first line of vcf/ics-file): "BEGIN:VCARD" or "BEGIN:VCALENDAR"
  local calcarddav="${4}"      # dav-endpoint: "dav" for ownCloud/Nextcloud >= 9.0; "carddav"/"caldav" for ownCloud < 9.0
  local ex_users="${5}"        # needed for download of addressbooks from ownCloud/Nextcloud >= 9.0: "users/" (or empty string for ownCloud < 9.0)

  local -i exported i z index
  local line filename item_name file_received convert

  # check whether database returned 0 entries (meaning there is not a single calendar/addressbook in the database):
  if [[ -z ${uri:-} ]]; then
    _output echo "-- INFO: Couldn't find a single ${item} in your ${productname}!"
    # unset arrays (to not include calendardata for addressbook export):
    unset -v id principal uri displayname already_saved_as calendarcolor
    # there is not a single item to export, let's exit this function and proceed:
    return
  fi

  # counter for exported items:
  # (to be able to print message that there is no valid user in users.txt, if no calendar/addressbook was exported)
  exported=0

  # switch to datadirectory if we want to get addressbooks directly from database:
  [[ "${dbtype}" == "sqlite3" && "${fetch_from_database}" == "yes" ]] && cd "${datadirectory}"
  # set convert variable for PostgreSQL if we want to get addressbooks directly from database:
  if [[ "${dbtype}" == "pgsql" && "${fetch_from_database}" == "yes" ]]; then
    [[ "${item}" == "addressbook" ]] && convert="convert_from(carddata,'UTF8')"
    # shellcheck disable=SC2034
    [[ "${item}" == "calendar" ]] && convert="convert_from(calendardata,'UTF8')"
  fi

  # loop through array with addressbooks/calendars:
  for (( i=0; i<${#uri[@]}; i++ )); do

    if [[ "${complete_backup_from_database:-}" == "yes" ]]; then
      # (exclude birthday calendar (contact_birthdays), because it is an automatically created calendar from ownCloud/Nextcloud) and system-addressbook:
      if [[ "${uri[$i]}" != "contact_birthdays" && "${principal[$i]}" != "principals/system/system"  ]]; then

        # create filename like: username-(calendar-/addressbook-)name-date:
        filename="${principal[$i]}-${displayname[$i]}${item_extension}"
        # remove funky characters from filename:
        filename="${filename//[\/\\*? ]/_}"

        # create addressbook or calendar by reading data directly from database (option -f | --fetch-from-database):
        _output printf '%s' "+  saving ${item} ${filename} (from database)..."
        [[ "${item}" == "calendar" ]] && create_calendar_from_db
        [[ "${item}" == "addressbook" ]] && create_addressbook_from_db

        # check whether first line of saved file is a valid iCalendar/vCard header:
        check_for_valid_icsvcf

        # increase counter $exported, because at least one item has been downloaded successfully (even if it was an empty addressbook):
        exported=$((exported + 1))

      fi
      # continue for-loop with next item:
      continue

    fi

    # loop through array with usernames given in file with users credentials (users.txt):
    for index in "${!users[@]}"; do
      # compare prinicpal with username. If there is a match, we found an item to be downloaded
      # (exclude birthday calendar (contact_birthdays), because it is an automatically created calendar from ownCloud/Nextcloud):
      if [[ "${principal[$i]}" == "${user[$index]}" && "${uri[$i]}" != "contact_birthdays" ]]; then

        # create filename like: username-(calendar-/addressbook-)name-date:
        filename="${principal[$i]}-${displayname[$i]}${item_extension}"
        # remove funky characters from filename:
        filename="${filename//[\/\\*? ]/_}"

        # only if shared items shall be included: check if item was already downloaded and break if yes or mark as downloaded:
        if [[ "${include_shares}" == "yes" ]]; then
          # increase readability: id of current item is used as index ($z) for array already_saved_as which stores filenames of downloaded items.
          z=${id[$i]}
          # check if there is already an entry for that item, meaning that it was already downloaded:
          if [[ "${already_saved_as[$z]:-}" != "" ]]; then
            # create name of item for message:
            item_name="${principal[$i]}-${displayname[$i]}"
            # remove funky characters:
            item_name="${item_name//[\/\\*? ]/_}"
            # print message that item is already downloaded and break the for-loop going through usernames to continue with next addressbook/calendar:
            _output echo "+  Skipping ${item} '${item_name}': already saved as '${already_saved_as[$z]}'." && break
          fi
          # item has not yet been downloaded, but will be downloaded, so let's add it to the arraay $already_saved_as:
          already_saved_as[$z]="${filename}"
        fi

        if [[ "${fetch_from_database}" == "yes" ]]; then

          # create addressbook or calendar by reading data directly from database (option -f | --fetch-from-database):
          _output printf '%s' "+  saving ${item} ${filename} (from database)..."
          [[ "${item}" == "calendar" ]] && create_calendar_from_db
          [[ "${item}" == "addressbook" ]] && create_addressbook_from_db

        else

          # download item with curl (command uses export link provided by contacts/calendar app from ownCloud/Nextcloud):
          _output printf '%s' "+  Saving ${item} ${filename}..."
          # replace spaces in username or addressbook(/calendar)name with %20 (url encoding, to work more reliable with webserver)
          # (OR (in case curl exits with error): store exit code of curl to be able to react on error in separate function)
          curl -s ${trust} -o "${backupfolder_day}/${filename}" -u "${user[$index]}":"${pass[$index]}" "${nextcloud_url}/remote.php/${calcarddav}/${item}s/${ex_users}${user[$index]// /%20}/${uri[$i]// /%20}?export" || cerror=$?
          # if error code is set, call function to examine curls exit code and print according message to stderr:
          [[ -n "${cerror:-}" ]] && curl_error

        fi

        # check whether first line of saved file is a valid iCalendar/vCard header:
        check_for_valid_icsvcf

        # increase counter $exported, because at least one item has been downloaded successfully (even if it was an empty addressbook):
        exported=$((exported + 1))
        break # break the for-loop going through usernames to continue with next addressbook/calendar.
      fi
    done
  done

  # switch back to original directory:
  [[ "${dbtype}" == "sqlite3" && "${fetch_from_database}" == "yes" ]] && cd "${working_dir}"

  # there is no matching Nextcloud user, if there are calendars/addressbooks in database table but nothing has been exported:
  if [[ ${exported} == 0 ]]; then
    _output echo "-- NOTICE: Found ${item}s in database, but none of them belongs to one of the users given in '${users_file}'."
    _output echo "-- NOTICE: You may want to check '${users_file}' for valid ${productname} users!"
  fi

  # remove temporary file:
  rm -f "${tempfile}"

  # unset arrays (to not include calendardata for calendarsubscriptions or addressbook export):
  unset -v id principal uri displayname already_saved_as calendarcolor
}

create_calendar_from_db() {
  # create iCalendar (.ics file) by reading calendardata directly from database (option -f | --fetch-from-database):
  # according to: https://tools.ietf.org/html/rfc5545

  local line vtime component k ifs_original
  local -a tz_temp tz_data tz_ids

  # an iCalender file consists of calendar properties and calendar components.
  # Nextcloud/ownCloud store every event/todo completely as an iCalender item in a single table cell. We need to get those events,
  # ignore the calendar properties and (they are generated separately from other database entries) and collect the components. Each
  # event contains the according timezone-components. They are unique for each timezone, so we only need to collect each timezone once.

  # prepare database query (variable convert is needed for PostgreSQL) to collect all events from according calendarid:
  # shellcheck disable=SC2016
  db_query='"SELECT ${convert:-calendardata} FROM ${table_calendarobjects} WHERE calendarid=${id[$i]}"'

  # print generic iCalendar properties (BEGIN, VERSION, PRODID, CALSCALE):
  printf '%s\r\n' "BEGIN:VCALENDAR" "VERSION:2.0" "PRODID:https://github.com/BernieO/calcardbackup v${version%% *}" "CALSCALE:GREGORIAN" > "${backupfolder_day}/${filename}"

  # also calendarname and calendarcolor (if existent in database):
  printf '%s\r\n' "X-WR-CALNAME:${displayname[$i]}" >> "${backupfolder_day}/${filename}"
  if [[ "${calendarcolor[$i]}" != "NULL" ]]; then
    printf '%s\r\n' "X-APPLE-CALENDAR-COLOR:${calendarcolor[$i]}" >> "${backupfolder_day}/${filename}"
  fi

  # property names and property parameters are case insensitive, so let's switch on nocasematch for comparing strings:
  shopt -s nocasematch

  # store IFS (Intenal Field Separator) and set it to the null string (to prevent read from stripping leading and trailing whitespace from the line)
  # of course it is much more performant to do this outside of the loop (instead of 'while IFS= read -r line; do' as suggested often):
  ifs_original="${IFS}"
  IFS=

  # prepare variables:
  vtime=0
  tz_ids[0]="dummy"

  # read calendardata line by line and collect components:
  eval "${dbcommand}" "${db_query}" > "${tempfile}"
  while read -r line; do

    # vtime: is indicator for VTIMEZONE
    #   vtime=0 means: no VTIMEZONE component (yet) detected
    #   vtime=1 means: loop is within VTIMEZONE component, lines are collected to temp array tz_temp
    #   vtime=2 means: loop is within VTIMEZONE component, but VTIMEZONE was already collected before so this time it will be ignored

    # component: is indicator for an iCalendar component
    #   component unset: not looping inside an iCalendar component
    #   component defined: components value is name of iCalendar component (e.g. VEVENT, VTODO, VJOURNAL, ..., iana-component or x-component which must also not be ignored)

    case ${vtime} in
      2 )
        # looping within  VTIMEZONE and VTIMEZONE was already collected before and VTIMEZONE doesn't end yet: ignore line and continue with next line:
        [[ ${line} != END:VTI* ]] && continue
        ;;
      0 )
        # looping within an iCalendar component which is not a VTIMEZONE (vtime==0) and that has not ended yet: print line to ics-file and continue with next line:
        [[ ${line} != END:* && -n ${component:-} ]] && {
          # (replace LF (linefeed) with CRLF (carriage-return + linefeed) according to RFC5545
          #       with parameter expansion "${line/%[[:space:]]}")
          printf '%s\r\n' "${line/%[[:space:]]}" >> "${backupfolder_day}/${filename}"
          continue
        }
        ;;
    esac

    case "${line}" in
      BEGIN:VCALENDAR* )
        # we need to filter out BEGIN:VCALENDAR to catch beginnings of components (it's not needed anyway):
        continue
        ;;
      BEGIN:* )
        # something is beginning here!
        # it might be an alarm-component which resides inside an VEVENT or VTODO component
        # if $component is unset: an iCalendar component begins with this line, so store component name in component variable:
        [[ -z ${component:-} ]] && component="${line#*:}"
        # if this is the beginning of a VTIMEZONE component, set vtime indicator to 1
        # (we are now within a VTIMEZONE, but don't know yet whether this VTIMEZONE has been already collected):
        [[ ${component} == VTI* ]] && vtime=1
        ;;
      END:${component:-} )
        # something is ending here!
        # if line ends an iCalendar component: unset the component-variable:
        unset -v component
        # additionally reset vtime indicator (to 0) and continue with next line if we are ending an VTIMEZONE component that was collected before:
        [[ ${vtime} -eq 2 ]] && { vtime=0; continue; }
        ;;
      * )
        # not looping in an iCalendar component and line doesn't begin a component: ignore line and continue with next line:
        [[ -z ${component:-} ]] && continue
        ;;
    esac

    # BEGIN VTIMEZONE collect and compare:

    # if we are looping through a VTIMEZONE, we need to check whether we collected the VTIMEZONE with this TZID already:
    if [[ ${vtime} -eq 1 ]]; then

      # does this line define an timezone-id (TZID)?
      if [[ ${line} == TZID:* ]]; then
        # loop through array with collected timezone-ids and check whether TZID is already stored in $tz_ids
        # (start with second array item, because 1st is dummy to avoid check for unset array (changed in 0.7.0-11)):
        for (( k=1; k<${#tz_ids[@]}; k++ )); do
          if [[ "${tz_ids[$k]}" == "${line}" ]]; then
            # match: TZID is already present in array: remember that timezone is already saved (set vtime indicator to 2):
            vtime=2
            # unset temporary array (filled with partially collected timezone-data):
            unset -v tz_temp
            # current VTIMEZONE component is already collected, so let's continue with the next line from database:
            continue 2
          fi
        done

        # save timezone_id, since it is not yet in the array for comparing timezone_ids:
        tz_ids+=("${line}")
      fi

      # add line to temporary tz-array:
      tz_temp+=("${line}")

      # check for END:VTIMEZONE:
      if [[ ${line} == END:VTI* ]]; then
        # transfer VTIMEZONE from the temporary array to the array containing all collected VTIMEZONE data:
        for (( k=0; k<${#tz_temp[@]}; k++ )); do
          tz_data+=("${tz_temp[$k]/%[[:space:]]}")
        done
        # reset vtime indicator to 0:
        vtime=0
        # unset tz_temp, so there wont be any old data when collecting the next found timezone:
        unset -v tz_temp
      fi
      # line was already stored in tz_temp array, let us get the next line from database:
      continue
    fi

    # END VTIMEZONE collect and compare

    # output line:
    printf '%s\r\n' "${line/%[[:space:]]}" >> "${backupfolder_day}/${filename}"

  done < "${tempfile}"

  # reset IFS to its original value (was set to null string before to prevent read from stripping leading and trailing whitespace from the line):
  IFS="${ifs_original}"

  # at this point of stage  all components (except for VTIMEZONES) are saved in $backupfolder_day/$filename
  # loop through array containing all VTIMEZONES and save the VTIMEZONE components at the end of the iCalendar object $backupfolder_day/$filename:
  if [[ -n ${tz_data:-} ]]; then
    for (( k=0; k<${#tz_data[@]}; k++ )); do
      printf '%s\r\n' "${tz_data[$k]}" >> "${backupfolder_day}/${filename}"
    done
  fi

  # important: add END:VCALENDAR as last line to the iCalendar file:
  printf '%s\r\n' "END:VCALENDAR" >> "${backupfolder_day}/${filename}"

  # reset matching case sensitive:
  shopt -u nocasematch
}

create_calendarsubscription_files() {
  # creates textfiles with URLs to subscribed calendars

  local i index filename

  for (( i=0; i<${#id[@]}; i++ )); do      # go through array with calendarsubscriptions

    if [[ -n "${users_file:-}" ]]; then
      # loop through array with usernames given in file with users credentials (users.txt):
      for index in "${!users[@]}"; do
        # compare prinicpal with username. If there is no match: continue with next username
        [[ "${principal[$i]}" == "${user[$index]}" ]] && break
      done
      # continue with next id of calendarsubscriptions, if no matching user was found
      # (this is the case, if (index_of_users-array + 1) equals the number of elements of that array):
      [[ $(( index + 1 )) -eq ${#users[@]} ]] && continue
    fi

    # create filename like: username-(calendar-/addressbook-)name-date:
    filename="${principal[$i]}-${displayname[$i]}.webcal"
    # remove funky characters from filename:
    filename="${filename//[\/\\*? ]/_}"

    # create file with URL to subscribed calendar:
    _output printf '%s' "+  saving ${item} ${filename} ..."
    echo "${source[$i]}" > "${backupfolder_day}/${filename}"
    _output printf '%s\n' "...success!"

  done

  # unset arrays (to not include data of calendarsubscriptions for addressbook export):
  unset -v id principal displayname source
}

create_addressbook_from_db() {
  # create vCard addressbook (.vcf file) by reading cards directly from database (option -f | --fetch-from-database):

  # prepare database query (variable convert is needed for PostgreSQL) to collect all cards belonging to addressbookid:
  # shellcheck disable=SC2016
  db_query='"SELECT ${convert:-carddata} FROM ${table_cards} WHERE addressbookid=${id[$i]}"'

  # this is much less complex than iCalendar: a vCard addressbook is just single vCards stuck together one after the other.
  # so we just need to pipe the output the column carddata with id of the according addressbook to the addressbook file.
  # for more details see: https://tools.ietf.org/html/rfc6350:
  eval "${dbcommand}" "${db_query}" > "${backupfolder_day}/${filename}"
}

check_for_valid_icsvcf() {
  # checks whether saved file has a valid iCalendar/vCard header (checking first line should be enough for our purpose)

  # an empty addressbook results in an empty file (or no file for curl < 7.42.0), so we need to check whether we received a file that is not empty:
  file_received="yes" # let's say for now that a file has been downloaded and change it below if no addressbook has been exported.
  # check for addressbook and whether no file was received (for curl < 7.42.0) or file received has size of 0 (meaning empty file):
  if [[ "${item}" == "addressbook" && ! -s "${backupfolder_day}/${filename}" ]]; then
    # touch file to create empty file, if it was not created by curl on successful download of empty addressbook (which is the case for curl < 7.42.0)
    touch "${backupfolder_day}/${filename}"
    _output printf '%s\n' "...empty file. Addressbook '${displayname[$i]}' of user '${principal[$i]}' is empty."
    file_received="no" # because we have received an empty file and thus do not need to check whether it is a valid ics-/vcf-file
  fi

  # check for valid ics-/vcf-header in received file:
  if [[ "${file_received}" == "yes" ]]; then
    read -r line <"${backupfolder_day}/${filename}"  # reads first line of received file
    if [[ ! "${line}" =~ ${item_header} ]]; then     # no valid file, if first line of file doesn't match item_header
      # attach "-ERROR.txt" to filename:
      mv "${backupfolder_day}/${filename}" "${backupfolder_day}/${filename}-ERROR.txt"
      _output printf '%s\n' ""    # newline is needed for error-message to start on a separate line. Increases readability.
      # print error message and exit:
      error_exit "ERROR: the saved file is not a valid ${item}-file. Something went wrong." "My guess: either wrong configured URL to ${productname} or a wrong combination of username/password in users.txt." "You may want to check the saved file for any hints what went wrong: ${backupfolder_day}/${filename}-ERROR.txt"
    fi
    _output printf '%s\n' "...success!"
  fi
}

get_calendars() {
  # gets calendars and saves them in backup-folder. Have a look at used functions for more detailed explanations.

  query_database "${table_calendars}" "calendar"
  [[ "${include_shares}" == "yes" ]] && include_shares
  get_icsvcf_files "calendar" ".ics" "BEGIN:VCALENDAR" "${caldav}" ""

  # get calendarsubscriptions as well:
  query_database "${table_calendarsubscriptions}" "calendarsubscription"
  if [[ -n "${source:-}" ]]; then
  # create files with calendarsubscriptions, if table calendarsubscriptions is not empty:
    create_calendarsubscription_files
  else
    # print info, that there are no calendarsubscriptions in the installation, (if table calendarsubscriptions is empty):
    _output echo "+  No calendarsubscriptions found."
  fi
}

get_addressbooks() {
  # gets addressbooks and saves them in backup-folder. Have a look at used functions for more detailed explanations.

  query_database "${table_addressbooks}" "addressbook"
  [[ "${include_shares}" == "yes" ]] && include_shares
  get_icsvcf_files "addressbook" ".vcf" "BEGIN:VCARD" "${carddav}" "${extra_users}"
}

check_for_backup_files() {
  # checks for files in backup-directory and prints warning, if there are no files (meaning absolutely nothing has been downloaded).
  local backupfolder_content

  backupfolder_content="$(ls -A "${backupfolder_day}")"
  if [[ -z "${backupfolder_content}" ]]; then
    echo "-- WARNING: No files in backup directory - meaning no backup created !!" >&2
    backup_files_present="no"
    rm -r "${backupfolder_day}"  # remove empty backup folder
  else
    backup_files_present="yes"
  fi
}

pack_it() {
  # compresses backup

  _output echo "+  Compressing backup as *.${compression_method} file. Be patient - this may take a while."
  # change to backupfolder to make sure there won't be any funky paths in compressed file:
  cd "${backupfolder}"

  # compress backup using the configured method (zip or tar.gz):
  if [[ "${compression_method}" == "zip" ]]; then
    # use zip to compress folder with backed up files:
    zip -r -q "calcardbackup${day}.zip" "calcardbackup${day}" || error_exit "ERROR: Compressing the files produced an error. See lines right above."
  else
    # use tar.gz to compress folder with backed up files:
    tar -czf "calcardbackup${day}.tar.gz" "calcardbackup${day}" || error_exit "ERROR: Compressing the files produced an error. See lines right above."
  fi

  # switch back to original directory:
  cd "${working_dir}"
  # delete folder with uncompressed ics/vcf-files:
  rm -r "${backupfolder_day}"
  # path to backup needs to be stored in case backup shall be encrypted or calcardbackup is running in batch-mode (-b):
  path_to_backup="${backupfolder}/calcardbackup${day}.${compression_method}"
  _output echo "+  Backup successfully compressed!"

  # if backup shall NOT be encrypted, print path to backup:
  # (use || instead of && so that function returns true in any case - corrected in ver. 0.1.2)
  [[ "${encrypt_backup}" == "yes" ]] || _output echo "+  Find your backup here: ${path_to_backup}"
}

gpg_encrypt_backup() {
  # encrypts compressed backup

  # compose path to encrypted backup by adding ".gpg" to the path/filename of compressed backup:
  local path_encrypted_backup="${path_to_backup}.gpg"
  # encrypt compressed backup file:
  gpg --passphrase-file <(echo "${gpg_passphrase}") --cipher-algo AES256 --batch --no-tty --yes --output "${path_encrypted_backup}" -c "${path_to_backup}" || error_exit "ERROR: Encrypting the compressed backup did not work!" "Check messages above."
  # command to decrypt: gpg --passphrase-file <(echo "${gpg_passphrase}") --batch --output decrypted_output_file --decrypt encrypted_file

  # delete passphrase from memory:
  unset -v gpg_passphrase
  # delete compressed backup
  rm "${path_to_backup}"
  # path_to_backup has changed and needs to be stored, in case calcardbackup is running in batch-mode (-b):
  path_to_backup="${path_encrypted_backup}"
  _output echo "+  Backup successfully encrypted!"
  _output echo "+  Find your encrypted backup here: ${path_to_backup}"
}

keep_like_time_machine() {
  # keeps old backups like apples timemachine:
  #   - keeps daily backups for the last $keep_days_like_time_machine days
  #   - keeps weekly backups for the time before

  local deleted line dir
  # delete backups not created on a monday and older than $keep_days_like_time_machine days
  # (use option -daystart to set beginning of day = 0:00 am in order
  # to satisfy probably by users expected behavior of this function):

  _output echo "+  Delete old backups like time machine (keep daily for the last ${keep_days_like_time_machine} days; weekly before):"

  deleted="no"

  # find all files which are older than 14 days and read them line by line:
  find "${backupfolder}"/calcardbackup* -daystart -mtime +${keep_days_like_time_machine} -print > "${tempfile}"
  while read -r line; do
    # exit loop, if $line is empty
    [[ -z "${line:-}" ]] && break
    # continue, if $line contains $dir (because dir was already deleted, otherwise $(date) below complains about non existing files)
    [[ -n "${dir:-}" && "${line}" =~ ^${dir:-}/.+ ]] && continue
    # check, if line is a directory:
    if [[ -d "${line}" ]]; then
      dir="${line}"
    fi
    # check if file was not created on a monday:
    if [[ $(date +%u -r "$line") -ne 1 ]]; then
      # print notice about file and delete file/folder:
      _output echo "+     - ${line}"
      rm -r "${line}"
      # remember that something has been deleted:
      [[ "${deleted}" == "no" ]] && deleted="yes"
    fi
  done < "${tempfile}"

  # print notice, of nothing has been found to be deleted:
  [[ "${deleted}" == "yes" ]] || _output echo "+  No backups found to be deleted like time machine."
}

delete_old_backups() {
  # deletes backups older than the configured amount of days ($delete_backups_older_than)

  local deleted
  # delete backups older than $delete_backups_older_than days
  # (use option -daystart to set beginning of day = 0:00 am in order
  # to satisfy probably by users expected behavior of this function):
  deleted="$(find "${backupfolder}"/calcardbackup* -daystart -mtime +${delete_backups_older_than} -delete -exec echo "+     - " {} \;)" || error_exit "ERROR: deleting backups older than ${delete_backups_older_than} days produced above error."

  if [[ "${deleted}" != "" ]]; then
    # if there have been files deleted:
    # print info about which older backups have been deleted:
    _output echo "+  Those backups older than ${delete_backups_older_than} days have been deleted:"
    _output echo "${deleted}"
  else
    # if nothing has been found to delete:
    # print info that no backups were old enough to be deleted:
    _output echo "+  No backups older than ${delete_backups_older_than} days found to delete."
  fi
}

finish() {
  # last function to be executed. This is the end of calcardbackup
  # prints END-message or if in batch-mode (-b) only path to backup

  # print timestamp and END-message:
  _output echo "+  $(date) --> END calcardbackup"
  _output echo "+"
  _output echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  _output echo

  # if running in batch mode and there are backed up files - print path to backup:
  [[ "${mode:-}" == "batch" && "${backup_files_present}" == "yes" ]] && echo "${path_to_backup}"

  # exit without error, because script catches errors and exits on error with error-code:
  exit 0
}

curl_error() {
  # prints to curls exit code according message
  # ${cerror} is curls exit code

  if [[ "${cerror}" -eq 6 ]]; then
    # curl error 6: could not resolve host:
    if [[ "${nextcloud_url}" == "${nextcloud_url_overwrite}" ]]; then
      problem="Either that host is temporarily unavailable or 'overwrite.cli.url' in ${configphp} is wrong."
    else
      problem="Either that host is temporarily unavailable or given url is wrong."
    fi
    error_exit "ERROR: Curl error 6: could not resolve host \"${nextcloud_url}\"" "${problem}"
  elif [[ "${cerror}" -eq 60 ]]; then
    # curl error 60: cannot authenticate certificate (probably self-signed certificate):
    error_exit "ERROR: Curl error 60: cannot authenticate peer certificate with known CA certificates." "You need to use option -s or configure trustful_certificate=\"no\" in config file."
  fi
  # error message for any other (not 6 nor 60) curl error:
  error_exit "ERROR: Curl cannot get the requested file. This can have various reasons." "For clarification lookup Curl Error number ${cerror}"
}

error_exit() {
  # prints error message and exits script
  # if any arguments are passed, they all will be printed as error message

  echo "-- calcardbackup: ERROR --" >&2

  # print all arguments that have been passed to this function as error message:
  for message in "$@"; do
    echo "-- ${message}" >&2
  done
  echo "-- calcardbackup: Exiting." >&2

  # exit with error code 64, because I read somewhere that 1 is reserved.
  # Not so sure about that anymore though, but error code stays 64 for backwards compatibility:
  exit 64
}

print_help() {
  # prints short help text

  echo "calcardbackup version ${version}"
  echo "Usage: ./calcardbackup [DIRECTORY] [option [argument]] [option [argument]] [option [argument]] ..."
  echo "Find more details in attached file 'README.md' or visit 'https://github.com/BernieO/calcardbackup'"
}

check_argument() {
  # checks for argument, if an option passed on command line needs an argument

  # if option was last on command line and no argument is following:
  [[ -z "${1:-}" ]] && error_exit "Option '${option}' requires an additional argument."

  # if option was not last on command line, but an option (starting with a dash) is following instead of argument:
  # (use || instead of && so that function returns true in any case - corrected in ver. 0.4.2-3)
  [[ "${1:0:1}" != "-" ]] || error_exit "Invalid argument for option '${option}'"
}


###
### END: FUNCTION DEFINITIONS
###


set_required_paths
load_default_values


###
### BEGIN: parse command line for options/arguments
###

# if no option or only option -b/--batch given: configure script to read config file from script_dir
[[ ${#} -eq 0 || ( ${#} -eq 1 && "${1}" =~ -b|--batch ) ]] && config_file="${script_dir}/calcardbackup.conf"

# get nextcloud path, if first given argument doesn't start with a hyphen
if [[ ${#} -gt 0 && "${1}" != -* ]]; then
  nextcloud_path="${1}"
  shift
fi

# read options and their arguments and store them in according variables:
while [[ ${#} -gt 0 ]]
do
  # store argument for error message, if invalid argument for option provided
  # (needed because of needed shift to get different arguments)
  option="${1}"

  case "${1}" in
    -a | --address )
      shift
      check_argument "${1:-}"
      nextcloud_url="${1}"
    ;;
    -b | --batch )
      mode="batch"
    ;;
    -c | --configfile )
      shift
      check_argument "${1:-}"
      config_file="${1}"
    ;;
    -d | --date )
      shift
      # make sure argument passed to --date does not clash with any other option:
      if [[ -n "${1:-}" && ! "${1}" =~ -{1,2}[a-ehnorsuxz] ]]; then
        date_extension="${1}"
      else
        check_argument "${1:-}"
      fi
    ;;
    -e | --encrypt )
      shift
      check_argument "${1:-}"
      encrypt_backup="yes"
      passphrase_file="${1}"
    ;;
    -f | --fetch-from-database )
      # not mentioned in README.md as this is the default for calcardbackup >= 0.8.0
      fetch_from_database="yes"
      # make sure -f overrides -g, if both (-f and -g) is given (see below):
      f=1
    ;;
    -g | --get-via-http )
      # deprecated
      # this used to be the defaut for calcardbackup <= v0.7.2
      # make sure -f overrides -g, if both (-f and -g) is given (see above):
      [[ ${f:-} -eq 1 ]] || fetch_from_database="no"
    ;;
    -h | --help )
      print_help
      exit 0
    ;;
    -i | --include-shares )
      include_shares="yes"
    ;;
    -ltm | --like-time-machine )
      shift
      check_argument "${1:-}"
      keep_days_like_time_machine="${1}"
    ;;
    -na | --no-addressbooks )
      backup_addressbooks="no"
    ;;
    -nc | --no-calendars )
      backup_calendars="no"
    ;;
    -o | --output )
      shift
      check_argument "${1:-}"
      backupfolder="${1}"
    ;;
    -p | --snap )
      snap="yes"
    ;;
    -r | --remove )
      shift
      check_argument "${1:-}"
      delete_backups_older_than="${1}"
    ;;
    -s | --selfsigned )
      trustful_certificate="no"
    ;;
    -u | --usersfile )
      shift
      check_argument "${1:-}"
      users_file="${1}"
    ;;
    -x | --uncompressed )
      compress="no"
    ;;
    -z | --zip )
      compression_method="zip"
    ;;
    * )
      _output echo "-  WARNING! Unrecognized option: ${1}"
    ;;
  esac
  shift
done

###
### END: parse command line for options/arguments
###


preparations
read_config_php
case ${curl_installed} in
  yes )
    # read status.php only if cURL is installed:
    read_status_php
    ;;
  no )
    # cURL is not installed - don't read status.php and assign a default value to productname:
    productname="Server"
    _output echo "+  Nextcloud/ownCloud ${productname} version ${version_config_php} detected."
    ;;
esac
get_database_details
# only read file with user credentials, if we ar not doing a complete backup by fetching everything from database:
[[ "${complete_backup_from_database:-}" == "yes" ]] || read_users_txt
create_backup_folder
if [[ "${backup_calendars}" != "no" ]]
  then get_calendars
  else _output echo "+  Not backing up calenders as configured."
fi
if [[ "${backup_addressbooks}" != "no" ]]
  then get_addressbooks
  else _output echo "+  Not backing up addressbooks as configured."
fi
check_for_backup_files
if [[ "${backup_files_present}" == "yes" ]]; then
  if [[ "${compress}" == "no" ]]
    then _output echo "+  Find your uncompressed backup in folder ${backupfolder_day}/"
    else pack_it
  fi
  [[ "${encrypt_backup}" == "yes" ]] && gpg_encrypt_backup
fi
[[ "${keep_days_like_time_machine}" -gt 0 ]] && keep_like_time_machine
[[ "${delete_backups_older_than}" -gt 0 ]] && delete_old_backups
finish
