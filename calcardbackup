#!/bin/bash

# calcardbackup by BernieO - extracts Own-/Nextcloud calendars and addressbooks
# Source: https://github.com/BernieO/calcardbackup
# Copyright (C) 2017 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################



_output() {
  [ "$mode" == "batch" ] && "$@" >> /dev/null
  [ "$mode" == "loud" ] && "$@"
}

get_absolute_path() {
  if [[ ! "${2}" = /* ]]; then
    # change path of ${2} (file) relative to ${1} (dir) to absolute path and remove trailing slashes:
    absolute_path=$(readlink -m "${1}/${2}")
  else
    # if ${2} contains already absolute path, then only remove trailing slashes:
    absolute_path=$(readlink -m "${2}")
  fi
  echo "${absolute_path}"
}

check_readable_file() {
  # checks if path is file and readable. $1 is path to file, $2 is short verbal explanation of file for error message.
  [ ! -f "${1}" ] || [ ! -r "${1}" ] && error_exit "ERROR: Can't read ${2}" "I need to be able to read ${1}"
}

set_required_paths() {
  # store current directory, because we have to change dir later and need to come back to where we were (because of unknown hook commands):
  working_dir=$(pwd)
  # get path to scripts dir:
  script_dir=$(readlink -m "${BASH_SOURCE[0]}")
  script_dir=$(dirname "${script_dir}")
}

load_default_values() {
  # assign default values:
  nextcloud_url="https://www.my_nextcloud.net"
  trustful_certificate="yes"
  date_extension="-%Y-%m-%d"
  delete_backups_older_than="0"
  compress="yes"
  compression_method="tar.gz"
  encrypt_backup="no"
  passphrase="1234"
}

read_config_file() {
  # absolute path to config file:
  config_file=$(readlink -m "${config_file}")
  config_file_dir=$(dirname "${config_file}")
  _output echo "+  Using configuration file ${config_file}, ignoring all other command line options."
  load_default_values # if more options have been passed to command: ignore all options except for -b

  # check if config file is a file and readable:
  check_readable_file "${config_file}" "calcardbackups config file."
  # check config file for correct syntax (only comments, variable declarations and empty lines allowed)
  grep -E -qv '^([[:space:]]*|[[:space:]]*[a-z_]+="[^"]+"[[:space:]]*)(#.*)?$' "${config_file}"
  [ "$?" -eq 0 ] && error_exit "ERROR: invalid config file! only variable-declarations, comments and empty lines allowed." "Edit configuration file and run sript again."
  # config file is readable and has correct syntax. So let's include it now:
  . "${config_file}"
  # change paths (relative to config files directory) to absolute paths, remove trailing slashes
  [ -z ${nextcloud_path:-} ] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud to be configured." "Check value of variable 'nextcloud_path' in ${config_file}"
  nextcloud_path=$(get_absolute_path "${config_file_dir}" "${nextcloud_path}")
  [ -z ${users_file:-} ] || users_file=$(get_absolute_path "${config_file_dir}" "${users_file}")
  [ -z ${backupfolder:-} ] ||Â backupfolder=$(get_absolute_path "${config_file_dir}" "${backupfolder}")
}

preparations() {
  # print timestamp
  _output printf "\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
  _output echo "+"
  _output echo "+  $(date) --> START calcardbackup"
  _output echo "+  Checking dependencies and preparing..."

  # check for packages curl, sed, grep
  which curl > /dev/null || error_exit "ERROR: Package 'curl' is needed for running this script." "Install with 'apt-get install curl' and run script again"
  which sed > /dev/null || error_exit "ERROR: Package 'sed' is needed for running this script." "Install with 'apt-get install sed' and run script again"
  which grep > /dev/null || error_exit "ERROR: Package 'grep' is needed for running this script." "Install with 'apt-get install grep' and run script again"

  # lazy mode: use calcardbackup.conf in scripts directory as config file:
#  if [ "${lazy_mode}" == "yes" ]; then
#    use_config_file="yes"
#    config_file="${script_dir}/calcardbackup.conf"
#  fi
  # option -c|--configfile or nothing at all or only -b is given: read config file
#  [ "${use_config_file}" == "yes" ] && read_config_file
  [ ! -z ${config_file:-} ] && read_config_file
  # error, if no path to ownCloud/Nextcloud and no configfile was given:
#  [ "${use_config_file}" == "no" ] && [ "${path_given}" == "no" ] && error_exit "ERROR: calcardbackup needs absolute path to Own-/Nextcloud as first argument!"
  [ -z ${config_file:-} ] && [ -z ${nextcloud_path:-} ] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud as first argument!"

  # remove trailing slashes from $nextcloud_path and $nextcloud_url:
  nextcloud_path=$(readlink -m "${nextcloud_path}")
  nextcloud_url=$(echo "${nextcloud_url}" | sed 's:/*$::')
  # location of ownClouds/Nextclouds config.php:
  configphp="${nextcloud_path}/config/config.php"

  # if using -c|--configfile or lazy mode: check $trustful_certificate for valid value:
  if [[ ! ${trustful_certificate} =~ ^(yes|no)$ ]]; then
    _output echo "-- NOTICE: Parameter 'trustful_certificate' is not valid (allowed is only \"yes\" or \"no\")."
    _output echo "-- NOTICE: Using default value instead: trustful_certificate=\"yes\""
    trustful_certificate="yes"
  fi
  # assign insecure-option for curl, depending on certificates trustfullness:
  [ "${trustful_certificate}" == "yes" ] && trust=""
  [ "${trustful_certificate}" == "no" ] && trust="--insecure"

  # if $users_file is empty or not not set it to '${script_dir}/users.txt' in script's dir
  [ -z ${users_file:-} ] && users_file="${script_dir}/users.txt"
  # check if users.txt is a file and readable:
  check_readable_file "${users_file}" "file with usernames and passwords."

  # if $backupfolder is empty or not set: set it to 'backups/' in script's dir
  [ -z ${backupfolder:-} ] && backupfolder="${script_dir}/backups/"
  # absolute path to backupfolder (writeable test follows later):
  backupfolder=$(readlink -m "${backupfolder}")

  # make sure the configured date format in $date_extension is valid:
  if [ ! $(date +"${date_extension}" 2>/dev/null) ]; then
    [ -z ${config_file:-} ] && _output echo "-- NOTICE: Argument to option '-d|--date' has no valid format (check 'man date' for valid formats)."
    [ -n ${config_file:-} ] && _output echo "-- NOTICE: Parameter 'date_extension' has no valid format (check 'man date' for valid formats)."
    _output echo "-- NOTICE: Using default value instead: \"-%Y-%m-%d\""
    date_extension="-%Y-%m-%d"
  fi

  # make sure $delete_backups_older_than is a positive integer and set it to 0 if not:
  if [[ ! ${delete_backups_older_than} =~ ^[0-9]+$ ]]; then
    [ -z ${config_file:-} ] && _output echo "-- NOTICE: Argument to option '-r/--remove' is not a positive number."
    [ -n ${config_file:-} ] && _output echo "-- NOTICE: Parameter 'delete_backups_older_than' is not a positive number."
    _output echo "-- NOTICE: Using default value of 0 instead (not deleting anything)."
    delete_backups_older_than="0"
  fi

  if [ "${compression_method}" == "zip" ]; then
    # check for package zip
    which zip > /dev/null || error_exit "ERROR: You chose to compress backed up files with 'zip' instead of 'tar.gz'." "Therefore package 'zip' is needed. Install with 'apt-get install zip' and run script again"
  else
    compression_method="tar.gz"
  fi

  # check $encrypt_backup for valid value:
  if [[ ! ${encrypt_backup} =~ ^(yes|no)$ ]]; then
    # can only happen, if misconfigured in config-file
    _output echo "-- WARNING: Parameter 'encrypt_backup' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: encrypt_backup=\"no\""
    encrypt_backup="no"
  elif [ "${encrypt_backup}" == "yes" ]; then
    # check for gpg:
    which gpg > /dev/null || error_exit "ERROR: You chose to encrypt your backup." "Therefore package 'gnupg' is needed. Install with 'apt-get install gnupg' and run script again"
    if [ "${compress}" == "no" ]; then
      _output echo "-- WARNING: Can't encrypt uncompressed backup."
      _output echo "-- WARNING: Changing from uncompress to compress backup"
      compress="yes"
    fi
    if [ -z ${config_file:-} ]; then
      # get passphrase from on commandline given file:
      check_readable_file "${passphrase_file}" "file with passphrase."
      gpg_passphrase=$(head -n1 "${passphrase_file}")
    fi
    # error and exit, if backup shall be encrypted, but passphrase is on example value (1234) or empty:
    if [[ ${gpg_passphrase} =~ ^(1234|)$ ]]; then
      [ -z ${config_file:-} ] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change passphrase in file with passphrase and run sript again."
      [ -n ${config_file:-} ] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change 'gpg_passphrase' in configuration file and run sript again."
    fi
  fi
}

getvalue_from_configphp() {
  # reads a line with a given paramter from config.php and echoes the parameters value:
  value=$(grep "${1}" "${configphp}")
  value=${value%\'*} # throw away end including last '
  value=${value##*\'} # throw away beginning including last '
  echo "${value}"
}

read_config_php() {
  # reads config.php and assigns different paramters we need to know
  # check whether Nextclouds config-file is readable:
  check_readable_file "${configphp}" "configuration file of your Own-/Nextcloud installation."

  # get version of Nextcloud to configure correct dav-endpoint:
  version_config_php=$(getvalue_from_configphp "version")
  # get version number
  mainversion=${version_config_php%%.*}
  minimumversion="5"
  davchangeversion="9"
  # error and exit, if mainversion < 5.0:
  [ "${mainversion}" -lt "${minimumversion}" ] && error_exit "ERROR: This script only works with versions >= 5.0." "You are using Owncloud ${version_config_php}."
  if [ "${mainversion}" -ge "${davchangeversion}" ]; then
    # Values for Own-/Nextcloud >= 9.0:
    caldav="dav"
    carddav="dav"
    table_calendars="oc_calendars"
    table_addressbooks="oc_addressbooks"
    row_principaluri="principaluri"
    # correction of export-link of addressbooks for Own-/Nextcloud >= 9.0:
    extra_users="users/"
  else
    # Values for Owncloud < 9.0:
    caldav="caldav"
    carddav="carddav"
    table_calendars="oc_clndr_calendars"
    table_addressbooks="oc_contacts_addressbooks"
    row_principaluri="userid"
    # must be empty for Owncloud < 9.0:
    extra_users=""
  fi
  # those values are the same for Owncloud < 9.0 und Own-/Nextcloud >= 9.0
  row_uri="uri"
  row_displayname="displayname"

  # get nextcloud_url from config.php or from config file and error, if something is weird:
  nextcloud_url_default="https://www.my_nextcloud.net"
  nextcloud_url_overwrite=$(getvalue_from_configphp "overwrite.cli.url")
  if [ "${nextcloud_url}" != "${nextcloud_url_default}" ] && [ "${nextcloud_url}" != "${nextcloud_url_overwrite}" ] && [ "${nextcloud_url_overwrite}" != "" ]; then
    # use overwrite.cli.uri and print Warning, if nextcloud_url has been configured to something other than default or overwrite.cli.url
    # (last test in if statement above: make sure overwrite.cli.url is present and not empty):
    _output echo "--"
    _output echo "-- WARNING: Configured Nextcloud-URL differs from 'overwrite.cli.url' in config.php"
    _output echo "-- ${nextcloud_url}/   ==>   given with option -a/--address or found in config file."
    _output echo "-- ${nextcloud_url_overwrite}/   ==>   detected in ${configphp}"
    _output echo "-- Using the latter one!"
    _output echo "--"
    nextcloud_url=${nextcloud_url_overwrite}
  elif [ "${nextcloud_url}" == "${nextcloud_url_default}" ] && [ "${nextcloud_url_overwrite}" == "" ]; then
    # Error, if nextcloud_url is on default value and config.php contains no overwrite.cli.url (or is empty)
    error_exit "ERROR: Can't retrieve url from ${configphp}" "In your case the URL needs to be passed to the script (via -a/--address or config file)"
  elif [ "${nextcloud_url_overwrite}" != "" ]; then
    # if overwrite.cli.uri is found (and nextcloud_url is on default value): use it as nextcloud_url
    nextcloud_url=${nextcloud_url_overwrite}
  fi
  # Print url which will be used:
  _output echo "+  Using URL ${nextcloud_url}"
}

read_status_php() {
  # check whether URL to Own-/Nextcloud is correct and store productname (Owncloud/Nextcloud):
  status_php=$(curl -s ${trust} "${nextcloud_url}/status.php")
  cerror=$?
  [ "${cerror}" -eq 0 ] || curl_error

  # check whether Own-/Nextcloud can be found at nextcloud_url with return of status.php
  # check regex with regex101.com (checked with versions mentioned below)
  # Output of status.php of the different versions:
  # Owncloud 5.0.9   {"installed":"true","version":"5.0.38","versionstring":"5.0.19","edition":""}
  # Owncloud 6.0.9   {"installed":"true","version":"6.0.9.2","versionstring":"6.0.9","edition":""}
  # Owncloud 7.0.15  {"installed":"true","version":"7.0.15.2","versionstring":"7.0.15","edition":""}
  # Owncloud 8.0.16  {"installed":true,"maintenance":false,"version":"8.0.16.3","versionstring":"8.0.16","edition":""}
  # Owncloud 8.1.12  {"installed":true,"maintenance":false,"version":"8.1.12.2","versionstring":"8.1.12","edition":""}
  # Owncloud 8.2.10  {"installed":true,"maintenance":false,"version":"8.2.10.2","versionstring":"8.2.10","edition":""}
  # Owncloud 9.0.8   {"installed":true,"maintenance":false,"version":"9.0.8.2","versionstring":"9.0.8","edition":""}
  # Owncloud 9.1.4   {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"9.1.4","edition":""}
  # Owncloud 10 alpha{"installed":"true","maintenance":"false","needsDbUpgrade":"false","version":"10.0.0.4","versionstring":"10.0.0 alpha","edition":"Community","productname":"ownCloud"}
  # Nextcloud 9.0.57 {"installed":true,"maintenance":false,"version":"9.0.57.2","versionstring":"9.0.57","edition":""}
  # Nextcloud 10.0.4 {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"10.0.4","edition":""}
  # Nextcloud 11.0.2 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"11.0.2.7","versionstring":"11.0.2","edition":"","productname":"Nextcloud"}
  grep -E -q '^\{"installed":"?(true|false)"?,("maintenance":"?(true|false)"?,("needsDbUpgrade":"?(true|false)"?,)?)?"version":"[[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}(\.[[:digit:]]{1,2})?","versionstring":"[[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}","edition":"[^"]*"(,"productname":"(ownCloud|Nextcloud)")?\}$' <<< ${status_php}
  [ $? != 0 ] && error_exit "ERROR: No Own-/Nextcloud Installation found at ${nextcloud_url} !"

  # get version from status.php:
  version_status_php=${status_php#*version\":\"}
  version_status_php=${version_status_php%%\"*}
  # get versions first number (needed for detection of Nextcloud 10):
  mainversion_status_php=${version_status_php%%.*}
  # get versionstring from status_php (needed for detection of Nextcloud 9):
  versionstring_status_php=${status_php#*versionstring\":\"}
  versionstring_status_php=${versionstring_status_php%%\"*}

  productname="ownCloud"

  # set productname to Nextcloud if status.php delivers it (this is the case for Nextcloud >= 11.0):
  grep -E -q '"productname":"Nextcloud"' <<< ${status_php} && productname="Nextcloud"

  # for mainversion 9 we need to find out whether product is ownCloud 9.x or Nextcloud 9.x or Nextcloud 10.x
  if [ "${mainversion_status_php}" -eq 9 ]; then

    # Nextcloud 10 has different main version numbers in version and versionstring delivered by status.php:
    # get main version number from versionstring:
    mainversionstring_status_php=${versionstring_status_php%%.*}
    # Nextcloud 9 has last number greater or equal than 50 in versionstring (first tagged version on github was 9.0.50):
    # get last number of versionstring:
    lastversionstring_status_php=${versionstring_status_php##*.}
    [ "${mainversion_status_php}" -lt "${mainversionstring_status_php}" ] || [ "${lastversionstring_status_php}" -ge 50 ] && productname="Nextcloud"
  fi

  _output echo "+  ${productname} ${versionstring_status_php} detected."

  # check whether version of config.php is the same than version of status.php
  [ "${version_status_php}" != "${version_config_php}" ] && error_exit "ERROR: different versions detected:" "${productname} ${version_status_php} found at ${nextcloud_url}" "${productname} ${version_config_php} found at ${nextcloud_path}" "check configured url and path in config file '${config_file}'"

  # check for installed=true in status.php
  grep -E -q '"installed":"?true"?' <<< ${status_php} || error_exit "ERROR: ${nextcloud_url}/status.php does not contain \"installed\":\"true\"!" "You need to check your ${productname} Installation!"
  # check for maintenance=false for versions >= 8.0 in status.php
  if [ "$mainversion" -ge 8 ]; then
    grep -E -q '"maintenance":"?false"?' <<< ${status_php} || error_exit "ERROR: ${productname} is in maintenance mode!" "Disable maintenance mode with command \"sudo -u www-data php ${
nextcloud_path}/occ maintenance:mode --off\" and run script again"
  fi
}

get_database_details() {
  # get database details:
  dbtype=$(getvalue_from_configphp "dbtype")
  case "${dbtype}" in
    mysql)
      dbname=$(getvalue_from_configphp "dbname")
      dbhost=$(getvalue_from_configphp "dbhost")
      dbuser=$(getvalue_from_configphp "dbuser")
      dbpassword=$(getvalue_from_configphp "dbpassword")
      dboptions="-h${dbhost} -u${dbuser} -p${dbpassword} ${dbname} -se"
      database="MySQL/MariaDB"
    ;;
    sqlite3)
      # check if command-line-interface of sqlite3 is installed:
      which sqlite3 > /dev/null || error_exit "ERROR: ${productname} database is sqlite3. Therefore this script requires package 'sqlite3'." "Install with 'apt-get install sqlite3' and run script again"
      datadirectory=$(getvalue_from_configphp "datadirectory") # has to be absolute path for Own-/Nextcloud, so no need to get absolute path
      sqlite3_database="${datadirectory}/owncloud.db"
      dboptions="owncloud.db" # we cd to ${datadirectory} later for database queries
      database="SQLite3"
     # check if sqlite3-database-file is readable:
      check_readable_file "${sqlite3_database}" "${productname}s SQLite3 database."
    ;;
    *)
      error_exit "ERROR: Unsupported Database type: ${dbtype}" "Only MySQL/MariaDB and SQLite3 are supported."
    ;;
  esac
  _output echo "+  Database of chosen ${productname} installation is ${database}."
}

read_users_txt() {
  # Reads file users:
  readarray -t users < "${users_file}"
  for i in "${!users[@]}"; do
    user[$i]=${users[$i]%%:*}
    pass[$i]=${users[$i]#*:}
  done
}

create_backup_folder() {
  # create backup folder:
  mkdir -p "${backupfolder}"
  [ "$?" -eq 0 ] || error_exit "ERROR: Backupfolder could not be created."

  # check if backupfolder is writable
  [ -w "${backupfolder}" ] || error_exit "ERROR: Backupfolder is not writable."

  day=$(date +"${date_extension}")
  backupfolder_day="${backupfolder}/calcardbackup${day}"
  path_to_backup="${backupfolder_day}" # depending on config changes later to path to compressed or encrypted backup
  mkdir -p "${backupfolder_day}"
}

query_database() {
  # Get details of calendars/addressbooks from database
  table="${1}"  # ${table_calendars} or ${table_addressbooks}
  item="${2}"   # "calendar" or "addressbook"
  # unset arrays (to not include calendardata for addressbook export):
  unset principal
  unset uri
  unset displayname

  _output echo "+  Looking for ${item}s in your ${productname}:"

  query_row_principaluri="select ${row_principaluri} from ${table} order by id"
  query_row_uri="select ${row_uri} from ${table} order by id"
  query_row_displayname="select ${row_displayname} from ${table} order by id"

  # cd needed for SQLite3, because ${datadirectory} could contain spaces --> sqlite3 would then need "${dboptions}", but mysql needs ${dboptions}:
  cd "${datadirectory}"
  # check if table exists:
  [ "${dbtype}" == "mysql" ] && check_table=$(mysql ${dboptions} "show tables like '${table}'")
  [ "${dbtype}" == "sqlite3" ] && check_table=$(sqlite3 ${dboptions} "SELECT name FROM sqlite_master WHERE type='table' AND name='${table}'")
  if [ "${check_table}" == "" ]; then
    _output echo "-- NOTICE: table '${table}' containing ${item}s does not exist in database."
    _output echo "-- NOTICE: Looks like ${productname} did not create any ${item}s yet."
  else
    while read calline; do
      principal+=("${calline}")
    done < <("${dbtype}" ${dboptions} "${query_row_principaluri}" | sed 's/principals\/users\///')
    while read calline; do
      uri+=("${calline}")
    done < <("${dbtype}" ${dboptions} "${query_row_uri}")
    while read calline; do
      displayname+=("${calline}")
    done < <("${dbtype}" ${dboptions} "${query_row_displayname}")
  fi
  cd "${working_dir}" # switch back to original directory (needed, because we don't know what will happen in hook file)
}

get_icsvcf_files() {

  item="${1}" item_extension="${2}" item_header="${3}" calcarddav="${4}" ex_users="${5}"

  # counter for exported items (if no calendar/addressbook was exported, there is no valid nextcloud user in users.txt):
  exported=0

  # Check whether database returned 0 entries (meaning there is not a single calendar/addressbook):
  if [ ${#uri[@]} == 0  ]; then
    _output echo "-- INFO: Couldn't find a single ${item} in your ${productname}!"
    # in this case: exported=1 though nothing exported, because different from no user match (see end of this function)
    exported=1
  fi

  count=${#uri[@]}
  for (( i=0; i<${count}; i++ )); do
    for index in "${!users[@]}"; do
      if [ "${principal[$i]}" == "${user[$index]}" ] && [ "${uri[$i]}" != "contact_birthdays" ]; then
        filename=${displayname[$i]// /_}
        _output printf "+  Saving ${item} ${principal[$i]}-${filename}${item_extension}..."
        curl -s ${trust} -o "${backupfolder_day}/${principal[$i]}-${filename}${item_extension}" -u "${user[$index]}":"${pass[$index]}" "${nextcloud_url}/remote.php/${calcarddav}/${item}s/${ex_users}${user[$index]}/${uri[$i]}?export"
        cerror=$?
        [ "${cerror}" -eq 0 ] || curl_error

        # an empty addressbook can't be exported, so we need to check whether we received a file:
        file_received="yes" # let us say for now a file has been downloaded and change it below if no addressbook has been exported.
        if [ "${item}" == "addressbook" ] && [ ! -f "${backupfolder_day}/${principal[$i]}-${filename}${item_extension}" ]; then
          _output printf "...not saved. Addressbook '${displayname[$i]}' of user '${principal[$i]}' is empty.\n"
          file_received="no" # set to 1 because we have not received a file and thus do not want to check whether it is a valid ics-/vcf-file
          exported=$((exported + 1)) # increase $exported, because we don't want to print notice that nothing has been found
          break
        fi

        # check for ics-/vcf-header in received file:
        if [ "${file_received}" == "yes" ] && [ ! $(head -n1 "${backupfolder_day}/${principal[$i]}-${filename}${item_extension}" | grep "${item_header}") ]; then
          mv "${backupfolder_day}/${principal[$i]}-${filename}${item_extension}" "${backupfolder_day}/${principal[$i]}-${filename}${item_extension}-ERROR.txt"
          _output printf "\n"
          error_exit "ERROR: the saved file is not a valid ${item}-file. Something went wrong." "My guess: either wrong configured URL to ${productname} or a wrong combination of username/password in users.txt." "You may want to check the saved file for any hints what went wrong: ${backupfolder_day}/${principal[$i]}-${filename}${item_extension}-ERROR.txt"
        fi
        exported=$((exported + 1))
        _output printf "...success!\n"
        break
      fi
    done
  done

  # there is no matching Nextcloud user, if there are calendars/addressbooks in database table but nothing has been exported:
  if [ ${exported} == 0 ]; then
    _output echo "-- NOTICE: Found ${item}s in database, but none of them belongs to one of the users given in 'users.txt'."
    _output echo "-- NOTICE: You may want to check '${users_file}' for valid ${productname} users!"
  fi
}

get_calendars() {
  # Get calendars and save them in backup-folder:
  query_database "${table_calendars}" "calendar"
  get_icsvcf_files "calendar" ".ics" "BEGIN:VCALENDAR" "${caldav}" ""
}

get_addressbooks() {
  # Get addressbooks and save them in backup-folder:
  query_database "${table_addressbooks}" "addressbook"
  get_icsvcf_files "addressbook" ".vcf" "BEGIN:VCARD" "${carddav}" "${extra_users}"
}

pack_it() {
  # print notice and quit, if there are no files in backup-directory:
  backupfolder_content=$(ls -A "${backupfolder_day}")
  [ -z "${backupfolder_content}" ] && _output echo "-- NOTICE: No files in backup directory. Nothing more to do." && finish

  _output echo "+  Compressing backup as *.${compression_method} file. Be patient - this may take a while."
  cd "${backupfolder}"
  if [ "${compression_method}" == "zip" ]; then
    # zip folder with backed up files:
    zip -r -q "calcardbackup${day}.zip" "calcardbackup${day}"
    [ $? -eq 0 ] || compress_error="1"
  else
    # use tar.gz to compress backup folder:
    tar -czf "calcardbackup${day}.tar.gz" "calcardbackup${day}"
    [ $? -eq 0 ] || compress_error="1"
  fi
  [ "${compress_error}" == "1" ] && error_exit "ERROR: Compressing the files produced an error. See lines right above."
  cd "${working_dir}" # switch back to original directory
  rm -r "${backupfolder_day}"
  path_to_backup="${backupfolder}/calcardbackup${day}.${compression_method}"
  _output echo "+  Backup successfully compressed!"
  [ "${encrypt_backup}" == "no" ] && _output echo "+  Find your backup here: ${path_to_backup}"
}

gpg_encrypt_backup() {
  # encrypts compressed backup
  path_encrypted_backup="${path_to_backup}.gpg"
  gpg --passphrase-file <(echo "${gpg_passphrase}") --cipher-algo AES256 --batch --no-tty --yes --output "${path_encrypted_backup}" -c "${path_to_backup}"
  # command to decrypt (maybe implemented in the future: gpg --passphrase-file <(echo "${gpg_passphrase}") --output decrypted_output_file -d encrypted_file
  [ "$?" == 0 ] || error_exit "ERROR: Encrypting the compressed backup did not work!" "Check messages above."
  # delete passphrase from memory:
  gpg_passphrase=""
  # delete compressed backup
  rm "${path_to_backup}"
  path_to_backup="${path_encrypted_backup}"
  _output echo "+  Backup successfully encrypted!"
  _output echo "+  Find your encrypted backup here: ${path_to_backup}"
}

delete_old_backups() {
  # deletes backups older than ${delete_backups_older_than} days:
  deleted=$(find "${backupfolder}"/calcardbackup* -daystart -mtime +${delete_backups_older_than} -delete -exec echo "+     - " {} \;)
  if [ "$?" -ne 0 ]; then
    error_exit "ERROR: deleting backups older than ${delete_backups_older_than} days produced above error."
  elif [ "${deleted}" != "" ]; then
    _output echo "+  Those backups older than ${delete_backups_older_than} days have been deleted:"
    _output echo "${deleted}"
  else
    _output echo "+  No backups older than ${delete_backups_older_than} days found to delete."
  fi
}

finish() {
  # print timestamp
  _output echo "+  $(date) --> END calcardbackup"
  _output echo "+"
  _output echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  _output echo
  [ "${mode}" == "batch" ] && echo "${path_to_backup}"
  exit 0
}

curl_error() {
  if [ "${cerror}" -eq 6 ]; then
    if [ "${nextcloud_url}" == "${nextcloud_url_overwrite}" ]; then
      problem="Either that host is temporarily unavailable or 'overwrite.cli.uri' in ${configphp} is wrong."
    else
      problem="Either that host is temporarily unavailable or given url is wrong."
    fi
    error_exit "ERROR: Curl error 6: could not resolve host \"${nextcloud_url}\"" "${problem}"
  elif [ "${cerror}" -eq 60 ]; then
    error_exit "ERROR: Curl error 60: cannot authenticate peer certificate with known CA certificates." "You need to use option -s or configure trustful_certificate=\"no\" in config file."
  fi
  error_exit "ERROR: Curl cannot get the requested file. This can have various reasons." "For clarification lookup Curl Error number ${cerror}"
}

error_exit() {
  echo "-- calcardbackup: ERROR --" >&2
  # if an error message is needed:
  for message in "$@"; do
    echo "-- ${message}" >&2
  done
  echo "-- calcardbackup: Exiting." >&2
  exit 64 # 1 is reserved.
}

check_argument() {
  [ -z "${1:-}" ] && error_exit "Option '${option}' requires an additional argument."
  [ "${1:0:1}" == "-" ] && error_exit "Invalid argument for option '${option}'"
}

# default values:
set_required_paths
load_default_values
mode="loud"

# read config file from script_dir, if run with no or only option -b/--batch
[ "${#}" == 0 ] || [[ "${#}" == 1 && "${1}" =~ -b|--batch ]] && config_file="${script_dir}/calcardbackup.conf"

# get nextcloud path if first argument starts with /
if [[ "${1}" != -* ]]; then
  nextcloud_path="${1}"
  shift
fi

while [ "${#}" -gt 0 ]
do
  option="${1}"
  case "${1}" in
    -a | --address )
      shift
      check_argument "${1:-}"
      nextcloud_url="${1}"
    ;;
    -b | --batch )
      mode="batch"
    ;;
    -c | --configfile )
      shift
      check_argument "${1:-}"
      config_file="${1}"
    ;;
    -d | --date )
      shift
      if [ ! -z "${1:-}" ] && [[ ! ${1} =~ -{1,2}[a-eoqrsuxz] ]]; then
        date_extension="${1}"
      else
        check_argument "${1:-}"
      fi
    ;;
    -e | --encrypt )
      shift
      check_argument "${1:-}"
      encrypt_backup="yes"
      passphrase_file="${1}"
    ;;
    -o | --output )
      shift
      check_argument "${1:-}"
      backupfolder="${1}"
    ;;
    -r | --remove )
      shift
      check_argument "${1:-}"
      delete_backups_older_than="${1}"
    ;;
    -s | --selfsigned )
      trustful_certificate="no"
    ;;
    -u | --usersfile )
      shift
      check_argument "${1:-}"
      users_file="${1}"
    ;;
    -x | --uncompressed )
      compress="no"
    ;;
    -z | --zip )
      compression_method="zip"
    ;;
    * )
      _output echo "-  WARNING! Unrecognized option: ${1}"
    ;;
  esac
  shift
done

preparations
read_config_php
read_status_php
get_database_details
read_users_txt
create_backup_folder
get_calendars
get_addressbooks
[ "${compress}" == "no" ] && _output echo "+  Find your uncompressed backup in folder ${backupfolder_day}/" || pack_it
[ "${encrypt_backup}" == "yes" ] && gpg_encrypt_backup
[ "${delete_backups_older_than}" -gt 0 ] && delete_old_backups
finish
