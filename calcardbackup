#!/bin/bash

# calcardbackup by BernieO - extracts Own-/Nextcloud calendars and addressbooks
# Source: https://github.com/BernieO/calcardbackup
# Copyright (C) 2017 BernieO
#
# This script is licensed under the GNU AFFERO GENERAL PUBLIC LICENSE v3.0
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#######################################################
#######################################################
##                                                   ##
##    Don't touch  anything below unless you know    ##
##           exactly what you are doing!             ##
##                                                   ##
#######################################################
#######################################################

# calcardbackup version:
version="pre-0.2.3_8 (19.08.2017), AGPL-3.0"

###
### BEGIN: FUNCTION DEFINITIONS
###

_output() {
  # print output only if not in batch mode (-b)
  # use || instead of && so that function returns true in any case - corrected in ver. 0.1.2
  [[ "${mode:-}" != "batch" ]] && "$@"
}

get_absolute_path() {
  if [[ "${2}" != /* ]]; then
    # change path of ${2} (file) relative to ${1} (dir) to absolute path and remove trailing slashes:
    absolute_path="$(readlink -m "${1}/${2}")"
  else
    # if ${2} contains already absolute path, then only remove trailing slashes:
    absolute_path="$(readlink -m "${2}")"
  fi
  echo "${absolute_path}"
}

check_readable_file() {
  # checks if path is file and readable. $1 is path to file, $2 is short verbal explanation of file for error message.
  [[ ! -f "${1}" ]] || [[ ! -r "${1}" ]] && error_exit "ERROR: Can't read ${2}" "I need to be able to read ${1}"
}

set_required_paths() {
  # store current directory, because we have to change dir later and need to be able to come back to where we were:
  working_dir="$(pwd)"
  # get path to scripts dir:
  script_dir="$(readlink -m "${BASH_SOURCE[0]}")"
  script_dir="$(dirname "${script_dir}")"
}

load_default_values() {
  # assign default values:
  nextcloud_url="https://www.my_nextcloud.net"
  trustful_certificate="yes"
  date_extension="-%Y-%m-%d"
  delete_backups_older_than="0"
  compress="yes"
  compression_method="tar.gz"
  encrypt_backup="no"
  passphrase="1234"
  backup_addressbooks="yes"
  backup_calendars="yes"
  include_shares="no"
}

read_config_file() {
  # absolute path to config file:
  config_file="$(readlink -m "${config_file}")"
  config_file_dir="$(dirname "${config_file}")"
  _output echo "+  Using configuration file ${config_file}, ignoring all other command line options."
  load_default_values # if more options have been passed to command: ignore all options except for -b

  # check if config file is a file and readable:
  check_readable_file "${config_file}" "calcardbackups config file."
  # check config file for correct syntax (only comments, variable declarations and empty lines allowed)
  regex='^([[:space:]]*|[[:space:]]*[a-z_]+="[^"]*"[[:space:]]*)(#.*)?$'
  while read -r line; do
    [[ ! "${line}" =~ ${regex} ]] && error_exit "ERROR: invalid config file! Only variable-declarations, comments and empty lines allowed." "Edit configuration file and run sript again."
  done <"${config_file}"
  # config file is readable and has correct syntax. So let's include it now:
  . "${config_file}"
  # change paths (relative to config files directory) to absolute paths, remove trailing slashes
  [[ -z "${nextcloud_path:-}" ]] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud to be configured." "Check value of variable 'nextcloud_path' in ${config_file}"
  nextcloud_path="$(get_absolute_path "${config_file_dir}" "${nextcloud_path}")"
  [[ -z "${users_file:-}" ]] || users_file="$(get_absolute_path "${config_file_dir}" "${users_file}")"
  [[ -z "${backupfolder:-}" ]] || backupfolder="$(get_absolute_path "${config_file_dir}" "${backupfolder}")"
}

preparations() {
  # print timestamp
  _output printf "\n%s\n" "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  _output echo "+"
  _output echo "+  $(date) --> START calcardbackup ver. ${version}"
  _output echo "+  Checking dependencies and preparing..."

  # check for package curl
  which curl > /dev/null || error_exit "ERROR: Package 'curl' is needed for running this script." "Install with 'apt-get install curl' and run script again"

  # if option -c|--configfile or nothing at all or only -b is given: read config file
  [[ ! -z "${config_file:-}" ]] && read_config_file
  # error, if no path to ownCloud/Nextcloud and no configfile was given:
  [[ -z "${config_file:-}" ]] && [[ -z "${nextcloud_path:-}" ]] && error_exit "ERROR: calcardbackup needs path to ownCloud/Nextcloud as first argument!"

  # remove trailing slashes from $nextcloud_path:
  nextcloud_path="$(readlink -m "${nextcloud_path}")"
  # remove trailing slashes from $nextcloud_url:
  while [[ "${nextcloud_url}" =~ /$ ]]; do
    nextcloud_url="${nextcloud_url%/}"
  done
  # location of ownClouds/Nextclouds config.php:
  configphp="${nextcloud_path}/config/config.php"

  # if using configfile: check $trustful_certificate for valid value:
  if [[ ! "${trustful_certificate}" =~ ^(yes|no)$ ]]; then
    _output echo "-- NOTICE: Parameter 'trustful_certificate' is not valid (allowed is only \"yes\" or \"no\")."
    _output echo "-- NOTICE: Using default value instead: trustful_certificate=\"yes\""
    trustful_certificate="yes"
  fi
  # assign insecure-option for curl, depending on certificates trustfullness:
  [[ "${trustful_certificate}" == "yes" ]] && trust=""
  [[ "${trustful_certificate}" == "no" ]] && trust="--insecure"

  # if $users_file is empty or not set: set it to 'users.txt' in script's dir
  [[ -z "${users_file:-}" ]] && users_file="${script_dir}/users.txt"
  # check if users.txt is a file and readable:
  check_readable_file "${users_file}" "file with usernames and passwords."

  # if $backupfolder is empty or not set: set it to 'backups/' in script's dir
  [[ -z "${backupfolder:-}" ]] && backupfolder="${script_dir}/backups/"
  # absolute path to backupfolder (writeable test follows later):
  backupfolder="$(readlink -m "${backupfolder}")"

  # make sure the configured date format in $date_extension is valid:
  if [[ ! "$(date +"${date_extension}" 2>/dev/null)" ]]; then
    [[ -z "${config_file:-}" ]] && _output echo "-- NOTICE: Argument to option '-d|--date' has no valid format (check 'man date' for valid formats)."
    [[ -n "${config_file:-}" ]] && _output echo "-- NOTICE: Parameter 'date_extension' has no valid format (check 'man date' for valid formats)."
    _output echo "-- NOTICE: Using default value instead: \"-%Y-%m-%d\""
    date_extension="-%Y-%m-%d"
  fi

  # make sure $delete_backups_older_than is a positive integer and set it to 0 if not:
  if [[ ! "${delete_backups_older_than}" =~ ^[0-9]+$ ]]; then
    [[ -z "${config_file:-}" ]] && _output echo "-- NOTICE: Argument to option '-r/--remove' is not a positive number."
    [[ -n "${config_file:-}" ]] && _output echo "-- NOTICE: Parameter 'delete_backups_older_than' is not a positive number."
    _output echo "-- NOTICE: Using default value of 0 instead (not deleting anything)."
    delete_backups_older_than="0"
  fi

  if [[ "${compression_method}" == "zip" ]]; then
    # check for package zip
    which zip > /dev/null || error_exit "ERROR: You chose to compress backed up files with 'zip' instead of 'tar.gz'." "Therefore package 'zip' is needed. Install with 'apt-get install zip' and run script again"
  else
    compression_method="tar.gz"
  fi

  # check $encrypt_backup for valid value:
  if [[ ! "${encrypt_backup}" =~ ^(yes|no)$ ]]; then
    # can only happen, if misconfigured in config-file
    _output echo "-- WARNING: Parameter 'encrypt_backup' is not valid (only \"yes\" or \"no\" allowed)."
    _output echo "-- WARNING: Using default value instead: encrypt_backup=\"no\""
    encrypt_backup="no"
  elif [[ "${encrypt_backup}" == "yes" ]]; then
    # check for gpg:
    which gpg > /dev/null || error_exit "ERROR: You chose to encrypt your backup." "Therefore package 'gnupg' is needed. Install with 'apt-get install gnupg' and run script again"
    if [[ "${compress}" == "no" ]]; then
      _output echo "-- WARNING: Can't encrypt uncompressed backup."
      _output echo "-- WARNING: Changing from uncompress to compress backup"
      compress="yes"
    fi
    if [[ -z "${config_file:-}" ]]; then
      # get passphrase from on commandline given file:
      check_readable_file "${passphrase_file}" "file with passphrase."
      # read first line from on commandline given file and use that as passphrase:
      read -r gpg_passphrase <"${passphrase_file}"
    fi
    # error and exit, if backup shall be encrypted, but passphrase is on example value (1234) or empty:
    if [[ "${gpg_passphrase}" =~ ^(1234|)$ ]]; then
      [[ -z "${config_file:-}" ]] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change passphrase in file with passphrase and run sript again."
      [[ -n "${config_file:-}" ]] && error_exit "ERROR: Passphrase is on insecure example value (1234)." "Change 'gpg_passphrase' in configuration file and run sript again."
    fi
  fi
}

getvalue_from_configphp() {
  # reads a line with a given paramter from config.php and echoes the parameters value:

  # (notice: multi-line comments (/* ... */) are not recognized, if no marker at beginning of line)
  regex="^[[:space:]]*'${1}'.*"
  while read -r line; do
    [[ "${line}" =~ $regex ]] && break
    line=""
  done <"${configphp}"
  if [[ "${line:-}" != "" ]]; then
    line=${line%\'*}  # throw away end including last '
    line=${line##*\'} # throw away beginning including last '
  fi
  echo "${line}"
}

read_config_php() {
  # reads config.php and assigns different paramters we need to know
  # check whether Nextclouds config-file is readable:
  check_readable_file "${configphp}" "configuration file of your Own-/Nextcloud installation."

  # get dbtableprefix for prefix string of table names:
  dbtableprefix="$(getvalue_from_configphp "dbtableprefix")"
  # set default dbtableprefix if empty or not found in config.php:
  [[ -z "${dbtableprefix:-}" ]] && dbtableprefix="oc_"

  # get version of Nextcloud to configure correct dav-endpoint:
  version_config_php="$(getvalue_from_configphp "version")"
  # get version number
  mainversion=${version_config_php%%.*}
  minimumversion="5"
  davchangeversion="9"
  # error and exit, if mainversion < 5.0:
  [[ "${mainversion}" -lt "${minimumversion}" ]] && error_exit "ERROR: This script only works with versions >= 5.0." "You are using Owncloud ${version_config_php}."
  if [[ "${mainversion}" -ge "${davchangeversion}" ]]; then
    # Values for Own-/Nextcloud >= 9.0:
    caldav="dav"
    carddav="dav"
    table_calendars="${dbtableprefix}calendars"
    table_addressbooks="${dbtableprefix}addressbooks"
    row_principaluri="principaluri"
    if [[ "${include_shares}" == "yes" ]]; then
      table_shares="${dbtableprefix}dav_shares"
      row_share_principaluri="principaluri"
      row_share_type="type"
      row_share_resourceid="resourceid"
    fi
    # correction of export-link of addressbooks for Own-/Nextcloud >= 9.0:
    extra_users="users/"
  else
    # Values for Owncloud < 9.0:
    caldav="caldav"
    carddav="carddav"
    table_calendars="${dbtableprefix}clndr_calendars"
    table_addressbooks="${dbtableprefix}contacts_addressbooks"
    row_principaluri="userid"
    if [[ "${include_shares}" == "yes" ]]; then
      table_shares="${dbtableprefix}share"
      row_share_principaluri="share_with"
      row_share_type="item_type"
      row_share_type_group="share_type" # needed for ownCloud < 9.0 to identify, if shared with group (and not with user)
      row_share_resourceid="item_source"
    fi
    # must be empty for Owncloud < 9.0:
    extra_users=""
  fi
  # those values are the same for Owncloud < 9.0 and Own-/Nextcloud >= 9.0
  row_id="id"
  row_uri="uri"
  row_displayname="displayname"
  table_group_user="${dbtableprefix}group_user"

  # get nextcloud_url from config.php or from config file and error, if something is weird:
  nextcloud_url_default="https://www.my_nextcloud.net"
  nextcloud_url_overwrite="$(getvalue_from_configphp "overwrite.cli.url")"
  if [[ "${nextcloud_url}" != "${nextcloud_url_default}" ]] && [[ "${nextcloud_url}" != "${nextcloud_url_overwrite}" ]] && [[ "${nextcloud_url_overwrite}" != "" ]]; then
    # use given URL but print notice, if nextcloud_url has been configured to something other than default or overwrite.cli.url
    # (last test in if statement above: make sure overwrite.cli.url is present and not empty):
    _output echo "-- NOTICE: Configured Nextcloud-URL differs from 'overwrite.cli.url' in config.php"
    _output echo "-- ${nextcloud_url_overwrite}/   ==>   detected in ${configphp}"
    _output echo "-- ${nextcloud_url}/   ==>   given with option -a/--address or found in config file."
  elif [[ "${nextcloud_url}" == "${nextcloud_url_default}" ]] && [[ "${nextcloud_url_overwrite}" == "" ]]; then
    # Error, if nextcloud_url is on default value and config.php contains no overwrite.cli.url (or is empty)
    error_exit "ERROR: Can't retrieve url from ${configphp}" "In your case the URL needs to be passed to the script (via -a/--address or config file)"
  elif [[ "${nextcloud_url_overwrite}" != "" ]]; then
    # if overwrite.cli.uri is found (and nextcloud_url is on default value): use it as nextcloud_url
    nextcloud_url="${nextcloud_url_overwrite}"
  fi
  # Print url which will be used:
  _output echo "+  Using URL ${nextcloud_url}"
}

read_status_php() {
  # check whether URL to Own-/Nextcloud is correct and store productname (Owncloud/Nextcloud):
  status_php="$(curl -s ${trust} "${nextcloud_url}/status.php")"
  cerror=$?
  [[ "${cerror}" -eq 0 ]] || curl_error

  # check whether Own-/Nextcloud can be found at nextcloud_url with return of status.php
  # check regex with regex101.com (checked with versions mentioned below)
  # Output of status.php of the different versions:
  # Owncloud 5.0.9   {"installed":"true","version":"5.0.38","versionstring":"5.0.19","edition":""}
  # Owncloud 6.0.9   {"installed":"true","version":"6.0.9.2","versionstring":"6.0.9","edition":""}
  # Owncloud 7.0.15  {"installed":"true","version":"7.0.15.2","versionstring":"7.0.15","edition":""}
  # Owncloud 8.0.16  {"installed":true,"maintenance":false,"version":"8.0.16.3","versionstring":"8.0.16","edition":""}
  # Owncloud 8.1.12  {"installed":true,"maintenance":false,"version":"8.1.12.2","versionstring":"8.1.12","edition":""}
  # Owncloud 8.2.10  {"installed":true,"maintenance":false,"version":"8.2.10.2","versionstring":"8.2.10","edition":""}
  # Owncloud 9.0.8   {"installed":true,"maintenance":false,"version":"9.0.8.2","versionstring":"9.0.8","edition":""}
  # Owncloud 9.1.4   {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"9.1.4","edition":""}
  # Owncloud 10.0.0  {"installed":"true","maintenance":"false","needsDbUpgrade":"false","version":"10.0.0.12","versionstring":"10.0.0","edition":"Community","productname":"ownCloud"}
  # Nextcloud 9.0.57 {"installed":true,"maintenance":false,"version":"9.0.57.2","versionstring":"9.0.57","edition":""}
  # Nextcloud 10.0.4 {"installed":true,"maintenance":false,"version":"9.1.4.2","versionstring":"10.0.4","edition":""}
  # Nextcloud 11.0.2 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"11.0.2.7","versionstring":"11.0.2","edition":"","productname":"Nextcloud"}
  # Nextcloud 12.0.0 {"installed":true,"maintenance":false,"needsDbUpgrade":false,"version":"12.0.0.29","versionstring":"12.0.0","edition":"","productname":"Nextcloud"}

  regex='^\{"installed":"?(true|false)"?,("maintenance":"?(true|false)"?,("needsDbUpgrade":"?(true|false)"?,)?)?"version":"[[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}(\.[[:digit:]]{1,2})?","versionstring":"[[:digit:]]{1,2}\.[[:digit:]]\.[[:digit:]]{1,2}","edition":"[^"]*"(,"productname":"[^"]*")?\}$'
  [[ ! "${status_php}" =~ ${regex} ]] && error_exit "ERROR: No Own-/Nextcloud Installation found at ${nextcloud_url} !"

  # get version from status.php:
  version_status_php=${status_php#*version\":\"}
  version_status_php=${version_status_php%%\"*}
  # get versions first number (needed for detection of Nextcloud 10):
  mainversion_status_php=${version_status_php%%.*}
  # get versionstring from status_php (needed for detection of Nextcloud 9):
  versionstring_status_php=${status_php#*versionstring\":\"}
  versionstring_status_php=${versionstring_status_php%%\"*}

  productname="ownCloud"

  # for mainversion 9 we need to find out whether product is ownCloud 9.x or Nextcloud 9.x or Nextcloud 10.x
  if [[ "${mainversion_status_php}" -eq 9 ]]; then

    # Nextcloud 10 has different main version numbers in version and versionstring delivered by status.php:
    # get main version number from versionstring:
    mainversionstring_status_php=${versionstring_status_php%%.*}
    # Nextcloud 9 has last number greater or equal than 50 in versionstring (first tagged version on github was 9.0.50):
    # get last number of versionstring:
    lastversionstring_status_php=${versionstring_status_php##*.}
    [[ "${mainversion_status_php}" -lt "${mainversionstring_status_php}" ]] || [[ "${lastversionstring_status_php}" -ge 50 ]] && productname="Nextcloud"
  fi

  # check for and use productname of status.php (for Nextcloud or custom productnames):
  regex='"productname":"[^"]+"'
  [[ "${status_php}" =~ ${regex} ]] && {
    productname_status_php=${status_php#*productname\":\"}
    productname_status_php=${productname_status_php%%\"*}
    productname="'${productname_status_php}'"
    unset -v productname_status_php
  }

  _output echo "+  ${productname} ${versionstring_status_php} detected."

  # check whether version of config.php is the same than version of status.php
  if [[ "${version_status_php}" != "${version_config_php}" ]]; then
     [[ -z "${config_file:-}" ]] && error_exit "ERROR: different versions detected:" "Version ${versionstring_status_php} found at ${nextcloud_url}" "Version ${version_config_php} found at ${nextcloud_path}" "check given path and given url (option -a)"
     [[ -n "${config_file:-}" ]] && error_exit "ERROR: different versions detected:" "Version ${versionstring_status_php} found at ${nextcloud_url}" "Version ${version_config_php} found at ${nextcloud_path}" "check configured path and url in config file '${config_file}'"
  fi

  # check for installed=true in status.php
  regex='"installed":"?true"?'
  [[ "${status_php}" =~ ${regex} ]] || error_exit "ERROR: ${nextcloud_url}/status.php does not contain \"installed\":\"true\"!" "You need to check your ${productname} Installation!"
  # check for maintenance=false for versions >= 8.0 in status.php
  if [[ "$mainversion" -ge 8 ]]; then
    regex='"maintenance":"?false"?'
    [[ "${status_php}" =~ ${regex} ]] || error_exit "ERROR: ${productname} is in maintenance mode!" "Disable maintenance mode with command \"sudo -u www-data php ${nextcloud_path}/occ maintenance:mode --off\" and run script again"
  fi
}

get_database_details() {
  # get database details:
  dbtype="$(getvalue_from_configphp "dbtype")"
  case "${dbtype}" in
    mysql)
      dbname="$(getvalue_from_configphp "dbname")"
      dbhost="$(getvalue_from_configphp "dbhost")"
      # check whether dbhost contains portnumber (e.g. 'localhost:3306') and store it for mysql commands:
      if [[ "${dbhost}" =~ ^.+:/.+$ ]]; then
        # dbhost contains socket after hostname (e.g. 'localhost:/var/run/mysqld/mysqld.sock'):
        dbprotocol="-S ${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      elif [[ "${dbhost}" =~ ^.+:[[:digit:]]+$ ]]; then
        # dbhost contains portnumber after hostname (e.g. '127.0.0.1:3306'):
        dbprotocol="-P ${dbhost#*:}"
        dbhost="${dbhost%%:*}"
      else
        # dbhost contains only hostname - tell mysql to use default portnumber:
        dbprotocol="-P 0"
      fi
      dbuser="$(getvalue_from_configphp "dbuser")"
      dbpassword="$(getvalue_from_configphp "dbpassword")"
      # mysql>=5.6 throws a warning when using password on command line interface: https://bugs.mysql.com/bug.php?id=66546
      # avoiding that with option --defaults-extra-file and printf as suggested by Dave James Miller: https://stackoverflow.com/questions/20751352/suppress-warning-messages-using-mysql-from-within-terminal-but-password-written/20854048#comment42372603_22933056
      # ATTENTION: variable $dbcommand will be passed to command "eval" later. So better take care when adding new stuff to $dbcommand!
      dbcommand='mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s" "${dbuser}" "${dbpassword}") -h "${dbhost}" ${dbprotocol} "${dbname}" -se '
      database="MySQL/MariaDB"
    ;;
    sqlite3)
      # check if command-line-interface of sqlite3 is installed:
      which sqlite3 > /dev/null || error_exit "ERROR: ${productname} database is sqlite3. Therefore this script requires package 'sqlite3'." "Install with 'apt-get install sqlite3' and run script again"
      datadirectory="$(getvalue_from_configphp "datadirectory")" # has to be absolute path for working Own-/Nextcloud, so no need to get absolute path
      sqlite3_database="${datadirectory}/owncloud.db"
      # use options '-list' and '-separator "|"' for sqlite3 command to override eventually existent user-specific config-file '~/.sqlite3rc':
      # ATTENTION: variable $dbcommand will be passed to command "eval" later. So better take care when adding new stuff to $dbcommand!
      dbcommand='sqlite3 -list -separator "|" owncloud.db ' # for database queries we do "cd ${datadirectory}" later so no need to use absolute path
      database="SQLite3"
      # check if sqlite3-database-file is readable:
      check_readable_file "${sqlite3_database}" "${productname}s SQLite3 database."
    ;;
    *)
      error_exit "ERROR: Unsupported Database type: ${dbtype}" "Only MySQL/MariaDB and SQLite3 are supported."
    ;;
  esac
  _output echo "+  Database of chosen ${productname} installation is ${database}."
}

read_users_txt() {
  # Reads file users:
  readarray -t users < "${users_file}"
  for i in "${!users[@]}"; do
    user[$i]="${users[$i]%%:*}"
    pass[$i]="${users[$i]#*:}"
  done
}

create_backup_folder() {
  # create backup folder:
  mkdir -p "${backupfolder}"
  [[ "$?" -eq 0 ]] || error_exit "ERROR: Backupfolder could not be created."

  # check if backupfolder is writable
  [[ -w "${backupfolder}" ]] || error_exit "ERROR: Backupfolder is not writable."

  day="$(date +"${date_extension}")"
  backupfolder_day="${backupfolder}/calcardbackup${day}"
  path_to_backup="${backupfolder_day}" # depending on config changes later to path to compressed or encrypted backup
  mkdir -p "${backupfolder_day}"
}

query_database() {
  # Get details of calendars/addressbooks from database
  table="${1}"  # ${table_calendars} or ${table_addressbooks}
  item="${2}"   # "calendar" or "addressbook"
  # unset arrays (to not include calendardata for addressbook export):
  unset -v id principal uri displayname

  _output echo "+  Looking for ${item}s in your ${productname}:"

  fields="${row_principaluri}, ${row_displayname}, ${row_uri}"
  [[ "${include_shares}" == "yes" ]] && fields="${row_id}, ${fields}" # we also need to get id of item to be able to include shares
  [[ "${dbtype}" == "mysql" ]] && fields="CONCAT_WS('|', ${fields})"  # adjust output format of MySQL/MariaDB to match output of SQLite3: field|field|field
  # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
  db_query='"select ${fields} from ${table} order by id"'

  # cd needed for SQLite3, because ${datadirectory} could contain spaces --> sqlite3 would then need "${dboptions}", but mysql needs ${dboptions}:
  cd "${datadirectory}"
  # check if table exists:
  [[ "${dbtype}" == "mysql" ]] && check_table="$(mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s" "${dbuser}" "${dbpassword}") -h "${dbhost}" ${dbprotocol} "${dbname}" -e "show tables like '${table}'")"
  [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table}'")"
  if [[ "${check_table}" == "" ]]; then
    _output echo "-- NOTICE: table '${table}' containing ${item}s does not exist in database."
    _output echo "-- NOTICE: Looks like ${productname} did not create any ${item}s yet."
  else
    while read line; do
      if [[ "${include_shares}" == "yes" ]]; then
        id+=("${line%%|*}")        # store id (first field) in array
        line="${line#*|}"          # cut first field (id)
      fi
      line="${line/principals\/users\/}" # remove "principals/users/" from line, to get username
      principal+=("${line%%|*}")   # store principal (=username, is first field) in array
      line="${line#*|}"            # cut first field (principal)
      displayname+=("${line%%|*}") # store displayname (is now first field) in array
      uri+=("${line##*|}")         # store uri (last field) in array
    done < <(eval "${dbcommand}" "${db_query}")
  fi
  cd "${working_dir}" # switch back to original directory
}

include_shares() {
  # look for shared items and add them to arrays:

  # cd needed for SQLite3, because ${datadirectory} could contain spaces --> sqlite3 would then need "${dboptions}", but mysql needs ${dboptions}:
  cd "${datadirectory}"

  # database only needs to be queried once for dav_shares, because same table for shared calendars and addressbooks:
  if [[ "${read_shared:-}" == "" ]]; then
    read_shared=1
    # check if table exists:
    [[ "${dbtype}" == "mysql" ]] && check_table="$(mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s" "${dbuser}" "${dbpassword}") -h "${dbhost}" ${dbprotocol} "${dbname}" -e "show tables like '${table_shares}'")"
    [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table_shares}'")"
    if [[ "${check_table}" == "" ]]; then
      _output echo "-- NOTICE: table '${table_shares}' containing shared calendars/addressbooks does not exist in database."
      _output echo "-- NOTICE: Looks like there are no shared calenders/addressbooks in your ${productname}."
    else
      # read table with details about shares:
      fields="${row_share_principaluri}, ${row_share_type}, ${row_share_resourceid}"
      # we also need to get share type to identify group-shares for ownCloud < 9.0:
      [[ "${mainversion}" -lt "${davchangeversion}" ]] && fields="${row_share_type_group}, ${fields}"
      [[ "${dbtype}" == "mysql" ]] && fields="CONCAT_WS('|', ${fields})"  # adjust output format of MySQL/MariaDB to match output of SQLite3: field|field|field
      # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
      db_query='"select ${fields} from ${table_shares} order by id"'
      while read line; do
        if [[ "${mainversion}" -lt "${davchangeversion}" ]]; then
          # for ownCloud < 9.0: store share_type_group (first field) in array
          # (will be 0 for user-share, 1 for group-share, 3 for public-share):
          share_type_group+=("${line%%|*}") # first field contains share-type_group
          line="${line#*|}"                 # cut first field (share_type_group) from array
        fi
        line="${line/principals\/users\/}"  # remove "principals/users/" to get username ("/principals/groups" stays there for groupcheck later)
        share_principal+=("${line%%|*}")    # store share_principal (is now first field) in array
        line="${line#*|}"                   # cut first field (share-principal)
        share_type+=("${line%%|*}")         # store share_type (is now first field) in array
        share_resourceid+=("${line##*|}")   # store share_resourceid (last field) in array
      done < <(eval "${dbcommand}" "${db_query}")

      # we also need to get info about group members to be able to backup calendars/addressbooks which are shared to groups:
      # check if table exists:
      [[ "${dbtype}" == "mysql" ]] && check_table="$(mysql --defaults-extra-file=<(printf "[client]\nuser = %s\npassword = %s" "${dbuser}" "${dbpassword}") -h "${dbhost}" ${dbprotocol} "${dbname}" -e "show tables like '${table_group_user}'")"
      [[ "${dbtype}" == "sqlite3" ]] && check_table="$(sqlite3 owncloud.db "SELECT name FROM sqlite_master WHERE type='table' AND name='${table_group_user}'")"
      if [[ "${check_table}" != "" ]]; then     # if table group_user exists, read values in array grouplist:
        fields="gid, uid"
        [[ "${dbtype}" == "mysql" ]] && fields="CONCAT_WS('|', ${fields})"   # adjust output format of MySQL/MariaDB to match output of SQLite3: field|field|field
        # ATTENTION: variable $db_query will be passed to command "eval" later. So better take care when adding new stuff to $db_query!
        db_query='"select ${fields} from ${table_group_user} order by gid"'
        while read line; do
          grouplist+=("${line}")
        done < <(eval "${dbcommand}" "${db_query}")
      fi
    fi
  fi

  # look for matches of share_resourceid and id and store values in a temp array:
  for (( i=0; i<${#id[@]}; i++ )); do                    # go through calender/addressbook-ids
    for (( s=0; s<${#share_resourceid[@]}; s++ )); do    # go through dav-shares-ids
      # if dav-share-id matches calendar/addressbook-id, we need to add it to the 'shares to be backed up'-list:
      if [[ "${share_resourceid[$s]}" == "${id[$i]}" ]] && [[ "${share_type[$s]}" == "${item}" ]]; then
        # make sure, principal of dav-share is not a group (group will be treated below) - second test is for ownCloud < 9.0, first test is for younger versions:
        if [[ ! "${share_principal[$s]}" =~ principals\/groups\/ ]] && [[ ! "${share_type_group[$s]:-}" =~ ^1$ ]]; then
          # add identified dav-share (shared with a user) to the 'shares to be backed up'-list:
          temp_principal+=("${share_principal[$s]}")
          temp_uri+=("${uri[$i]}_shared_by_${principal[$i]}")
          temp_displayname+=("${displayname[$i]}_shared_by_${principal[$i]}")
          temp_id+=("${share_resourceid[$s]}")
        else
          # if share-principal is a group: go through list with groups and their users and
          # add item to the 'shares to be backed up'-list for all users of that very group:
          for g in "${!grouplist[@]}"; do
            if [[ "${share_principal[$s]#*principals/groups/}" == "${grouplist[$g]%|*}" ]]; then
              # if item owner is member of group: do not add item to 'shares to be backed up'-list for owner, instead continue with next element
              # (owners item is already in the array with items to be downloaded):
              [[ "${grouplist[$g]#*|}" == "${principal[$i]}" ]] && continue

              # add item shared with group to 'shares to be backed up'-list:
              temp_principal+=("${grouplist[$g]#*|}")
              temp_uri+=("${uri[$i]}_shared_by_${principal[$i]}")
              temp_displayname+=("${displayname[$i]}_shared_by_${principal[$i]}")
              temp_id+=("${share_resourceid[$s]}")
            fi
          done
        fi
      fi
    done
  done

  # add values of 'shares to be backed up'-list to arrays which will later be used to download the files:
  for (( i=0; i<${#temp_principal[@]}; i++ )); do
    principal+=("${temp_principal[$i]}")
    uri+=("${temp_uri[$i]}")
    displayname+=("${temp_displayname[$i]}")
    id+=("${temp_id[$i]}")
  done

  # unset temp-arrays and for-loop-variables:
  unset -v temp_principal temp_uri temp_displayname temp_id i s g

  cd "${working_dir}" # switch back to original directory
}

get_icsvcf_files() {

  item="${1}" item_extension="${2}" item_header="${3}" calcarddav="${4}" ex_users="${5}"

  # counter for exported items (if no calendar/addressbook was exported, there is no valid nextcloud user in users.txt):
  exported=0

  # Check whether database returned 0 entries (meaning there is not a single calendar/addressbook):
  if [[ ${#uri[@]} == 0 ]]; then
    _output echo "-- INFO: Couldn't find a single ${item} in your ${productname}!"
    # in this case: exported=1 though nothing exported, because different from no user match (see end of this function)
    exported=1
  fi

  # array already_saved_as (stores filenames and (as index) ids of saved items) needs to be unset to not mix up addressbook data with calendar data:
  unset -v already_saved_as

  for (( i=0; i<${#uri[@]}; i++ )); do
    for index in "${!users[@]}"; do
      if [[ "${principal[$i]}" == "${user[$index]}" ]] && [[ "${uri[$i]}" != "contact_birthdays" ]]; then

        filename="${principal[$i]}-${displayname[$i]}${item_extension}"
        filename="${filename//[\/\\*? ]/_}" # remove funky characters from filename

        # only if shared items shall be included: check if item was already downloaded before and break if yes or mark as downloaded:
        if [[ "${include_shares}" == "yes" ]]; then
          z=${id[$i]} # increase readability: id of current item is used as index for array already_saved_as which stores filenames of downloaded items.
          if [[ "${already_saved_as[$z]:-}" != "" ]]; then
            item_name="${principal[$i]}-${displayname[$i]}"
            item_name="${item_name//[\/\\*? ]/_}" # remove funky characters
            _output echo "+  Skipping ${item} '${item_name}': already saved as '${already_saved_as[$z]}'." && break
          fi
          already_saved_as[$z]="${filename}"
        fi

        _output printf "%s" "+  Saving ${item} ${filename}..."
        curl -s ${trust} -o "${backupfolder_day}/${filename}" -u "${user[$index]}":"${pass[$index]}" "${nextcloud_url}/remote.php/${calcarddav}/${item}s/${ex_users}${user[$index]}/${uri[$i]}?export"
        cerror=$?
        [[ "${cerror}" -eq 0 ]] || curl_error

        # an empty addressbook results in an empty file (or no file for curl < 7.42.0), so we need to check whether we received a file that is not empty:
        file_received="yes" # let's say for now that a file has been downloaded and change it below if no addressbook has been exported.
        if [[ "${item}" == "addressbook" ]] && [[ ! -s "${backupfolder_day}/${filename}" ]]; then
          # touch file to create empty file, if it was not created by curl on successful download of empty file (which is the case for curl < 7.42.0)
          touch "${backupfolder_day}/${filename}"
          _output printf "%s\n" "...empty file. Addressbook '${displayname[$i]}' of user '${principal[$i]}' is empty."
          file_received="no" # because we have received an empty file and thus do not want to check whether it is a valid ics-/vcf-file
          exported=$((exported + 1)) # increase ${exported}, because we don't want to print notice that nothing has been found
          break
        fi

        # check for ics-/vcf-header in received file:
        read -r line <"${backupfolder_day}/${filename}"        # reads first line of received file
        if [[ "${file_received}" == "yes" ]] && [[ ! "${line}" =~ ${item_header} ]]; then    # no valid file, if first line of file doesn't match item_header
          mv "${backupfolder_day}/${filename}" "${backupfolder_day}/${filename}-ERROR.txt"
          _output printf "%s" "\n"
          error_exit "ERROR: the saved file is not a valid ${item}-file. Something went wrong." "My guess: either wrong configured URL to ${productname} or a wrong combination of username/password in users.txt." "You may want to check the saved file for any hints what went wrong: ${backupfolder_day}/${filename}-ERROR.txt"
        fi
        exported=$((exported + 1))
        _output printf "%s\n" "...success!"
        break
      fi
    done
  done

  # there is no matching Nextcloud user, if there are calendars/addressbooks in database table but nothing has been exported:
  if [[ ${exported} == 0 ]]; then
    _output echo "-- NOTICE: Found ${item}s in database, but none of them belongs to one of the users given in 'users.txt'."
    _output echo "-- NOTICE: You may want to check '${users_file}' for valid ${productname} users!"
  fi
}

get_calendars() {
  # Get calendars and save them in backup-folder:
  query_database "${table_calendars}" "calendar"
  [[ "${include_shares}" == "yes" ]] && include_shares
  get_icsvcf_files "calendar" ".ics" "BEGIN:VCALENDAR" "${caldav}" ""
}

get_addressbooks() {
  # Get addressbooks and save them in backup-folder:
  query_database "${table_addressbooks}" "addressbook"
  [[ "${include_shares}" == "yes" ]] && include_shares
  get_icsvcf_files "addressbook" ".vcf" "BEGIN:VCARD" "${carddav}" "${extra_users}"
}

check_for_backup_files() {
  # check for files in backup-directory and print warning, if there are no files:
  backupfolder_content="$(ls -A "${backupfolder_day}")"
  if [[ -z "${backupfolder_content}" ]]; then
    echo "-- WARNING: No files in backup directory - meaning no backup created !!" >&2
    backup_files_present="no"
    rm -r "${backupfolder_day}"  # remove empty backup folder
  else
    backup_files_present="yes"
  fi
}

pack_it() {
  # compress backup
  _output echo "+  Compressing backup as *.${compression_method} file. Be patient - this may take a while."
  cd "${backupfolder}"
  if [[ "${compression_method}" == "zip" ]]; then
    # zip folder with backed up files:
    zip -r -q "calcardbackup${day}.zip" "calcardbackup${day}"
    [[ $? -eq 0 ]] || compress_error="1"
  else
    # use tar.gz to compress backup folder:
    tar -czf "calcardbackup${day}.tar.gz" "calcardbackup${day}"
    [[ $? -eq 0 ]] || compress_error="1"
  fi
  [[ "${compress_error}" == "1" ]] && error_exit "ERROR: Compressing the files produced an error. See lines right above."
  cd "${working_dir}" # switch back to original directory
  rm -r "${backupfolder_day}"
  path_to_backup="${backupfolder}/calcardbackup${day}.${compression_method}"
  _output echo "+  Backup successfully compressed!"
  # use || instead of && so that function returns true in any case - corrected in ver. 0.1.2
  # if backup shall NOT be encrypted, print path to backup:
  [[ "${encrypt_backup}" == "yes" ]] || _output echo "+  Find your backup here: ${path_to_backup}"
}

gpg_encrypt_backup() {
  # encrypts compressed backup
  path_encrypted_backup="${path_to_backup}.gpg"
  gpg --passphrase-file <(echo "${gpg_passphrase}") --cipher-algo AES256 --batch --no-tty --yes --output "${path_encrypted_backup}" -c "${path_to_backup}"
  # command to decrypt: gpg --passphrase-file <(echo "${gpg_passphrase}") --batch --output decrypted_output_file --decrypt encrypted_file
  [[ "$?" == 0 ]] || error_exit "ERROR: Encrypting the compressed backup did not work!" "Check messages above."
  # delete passphrase from memory:
  unset -v gpg_passphrase
  # delete compressed backup
  rm "${path_to_backup}"
  path_to_backup="${path_encrypted_backup}"
  _output echo "+  Backup successfully encrypted!"
  _output echo "+  Find your encrypted backup here: ${path_to_backup}"
}

delete_old_backups() {
  # deletes backups older than ${delete_backups_older_than} days:
  deleted="$(find "${backupfolder}"/calcardbackup* -daystart -mtime +${delete_backups_older_than} -delete -exec echo "+     - " {} \;)"
  if [[ "$?" -ne 0 ]]; then
    error_exit "ERROR: deleting backups older than ${delete_backups_older_than} days produced above error."
  elif [[ "${deleted}" != "" ]]; then
    _output echo "+  Those backups older than ${delete_backups_older_than} days have been deleted:"
    _output echo "${deleted}"
  else
    _output echo "+  No backups older than ${delete_backups_older_than} days found to delete."
  fi
}

finish() {
  # print timestamp
  _output echo "+  $(date) --> END calcardbackup"
  _output echo "+"
  _output echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  _output echo
  [[ "${mode}" == "batch" ]] && [[ "${backup_files_present}" == "yes" ]] && echo "${path_to_backup}"
  exit 0
}

curl_error() {
  if [[ "${cerror}" -eq 6 ]]; then
    if [[ "${nextcloud_url}" == "${nextcloud_url_overwrite}" ]]; then
      problem="Either that host is temporarily unavailable or 'overwrite.cli.uri' in ${configphp} is wrong."
    else
      problem="Either that host is temporarily unavailable or given url is wrong."
    fi
    error_exit "ERROR: Curl error 6: could not resolve host \"${nextcloud_url}\"" "${problem}"
  elif [[ "${cerror}" -eq 60 ]]; then
    error_exit "ERROR: Curl error 60: cannot authenticate peer certificate with known CA certificates." "You need to use option -s or configure trustful_certificate=\"no\" in config file."
  fi
  error_exit "ERROR: Curl cannot get the requested file. This can have various reasons." "For clarification lookup Curl Error number ${cerror}"
}

error_exit() {
  echo "-- calcardbackup: ERROR --" >&2
  # if an error message is needed:
  for message in "$@"; do
    echo "-- ${message}" >&2
  done
  echo "-- calcardbackup: Exiting." >&2
  exit 64 # 1 is reserved.
}

print_help() {
  echo "calcardbackup version ${version}"
  echo "Usage: ./calcardbackup [DIRECTORY] [option [argument]] [option [argument]] [option [argument]] ..."
  echo "Find more details in attached file 'README.md' or visit 'https://github.com/BernieO/calcardbackup'"
}

check_argument() {
  [[ -z "${1:-}" ]] && error_exit "Option '${option}' requires an additional argument."
  [[ "${1:0:1}" == "-" ]] && error_exit "Invalid argument for option '${option}'"
}


###
### END: FUNCTION DEFINITIONS
###


set_required_paths
load_default_values

# check if options are passed via command line and store them in according variables:

# if no option or only option -b/--batch given: configure to read config file from script_dir
[[ "${#}" == 0 ]] || [[ "${#}" == 1 && "${1}" =~ -b|--batch ]] && config_file="${script_dir}/calcardbackup.conf"

# get nextcloud path, if first given argument doesn't start with a hyphen
if [[ "${1}" != -* ]]; then
  nextcloud_path="${1}"
  shift
fi

while [[ "${#}" -gt 0 ]]
do
  option="${1}"     # store for error message, if invalid argument for option provided (because of needed shift to get arguments)
  case "${1}" in
    -a | --address )
      shift
      check_argument "${1:-}"
      nextcloud_url="${1}"
    ;;
    -b | --batch )
      mode="batch"
    ;;
    -c | --configfile )
      shift
      check_argument "${1:-}"
      config_file="${1}"
    ;;
    -d | --date )
      shift
      # make sure argument passed to --date does not clash with any other option:
      if [[ ! -z "${1:-}" ]] && [[ ! "${1}" =~ -{1,2}[a-ehnorsuxz] ]]; then
        date_extension="${1}"
      else
        check_argument "${1:-}"
      fi
    ;;
    -e | --encrypt )
      shift
      check_argument "${1:-}"
      encrypt_backup="yes"
      passphrase_file="${1}"
    ;;
    -h | --help )
      print_help
      exit 0
    ;;
    -i | --include-shares )
      include_shares="yes"
    ;;
    -na | --no-addressbooks )
      backup_addressbooks="no"
    ;;
    -nc | --no-calendars )
      backup_calendars="no"
    ;;
    -o | --output )
      shift
      check_argument "${1:-}"
      backupfolder="${1}"
    ;;
    -r | --remove )
      shift
      check_argument "${1:-}"
      delete_backups_older_than="${1}"
    ;;
    -s | --selfsigned )
      trustful_certificate="no"
    ;;
    -u | --usersfile )
      shift
      check_argument "${1:-}"
      users_file="${1}"
    ;;
    -x | --uncompressed )
      compress="no"
    ;;
    -z | --zip )
      compression_method="zip"
    ;;
    * )
      _output echo "-  WARNING! Unrecognized option: ${1}"
    ;;
  esac
  shift
done


preparations
read_config_php
read_status_php
get_database_details
read_users_txt
create_backup_folder
[[ "${backup_calendars}" == "yes" ]] && get_calendars || _output echo "+  Not backing up calenders as configured."
[[ "${backup_addressbooks}" == "yes" ]] && get_addressbooks || _output echo "+  Not backing up addressbooks as configured."
check_for_backup_files
if [[ "${backup_files_present}" == "yes" ]]; then
  [[ "${compress}" == "no" ]] && _output echo "+  Find your uncompressed backup in folder ${backupfolder_day}/" || pack_it
  [[ "${encrypt_backup}" == "yes" ]] && gpg_encrypt_backup
fi
[[ "${delete_backups_older_than}" -gt 0 ]] && delete_old_backups
finish
